{
  "https://github.com/tiangolo/full-stack-fastapi-template": {
    "name": "full-stack-fastapi-template",
    "url": "https://github.com/tiangolo/full-stack-fastapi-template",
    "function_to_code": {
      "init": "def init(db_engine: Engine) -> None:\n    try:\n        # Try to create session to check if DB is awake\n        with Session(db_engine) as session:\n            session.exec(select(1))\n    except Exception as e:\n        logger.error(e)\n        raise e",
      "main": "def main() -> None:\n    logger.info(\"Initializing service\")\n    init(engine)\n    logger.info(\"Service finished initializing\")",
      "render_email_template": "def render_email_template(*, template_name: str, context: dict[str, Any]) -> str:\n    template_str = (\n        Path(__file__).parent / \"email-templates\" / \"build\" / template_name\n    ).read_text()\n    html_content = Template(template_str).render(context)\n    return html_content",
      "send_email": "def send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")",
      "generate_test_email": "def generate_test_email(email_to: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Test email\"\n    html_content = render_email_template(\n        template_name=\"test_email.html\",\n        context={\"project_name\": settings.PROJECT_NAME, \"email\": email_to},\n    )\n    return EmailData(html_content=html_content, subject=subject)",
      "generate_reset_password_email": "def generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
      "generate_new_account_email": "def generate_new_account_email(\n    email_to: str, username: str, password: str\n) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - New account for user {username}\"\n    html_content = render_email_template(\n        template_name=\"new_account.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": settings.server_host,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
      "generate_password_reset_token": "def generate_password_reset_token(email: str) -> str:\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt",
      "verify_password_reset_token": "def verify_password_reset_token(token: str) -> str | None:\n    try:\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        return str(decoded_token[\"sub\"])\n    except JWTError:\n        return None",
      "custom_generate_unique_id": "def custom_generate_unique_id(route: APIRoute) -> str:\n    return f\"{route.tags[0]}-{route.name}\"",
      "create_user": "def create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    return user",
      "update_user": "def update_user(\n    *,\n    session: SessionDep,\n    user_id: int,\n    user_in: UserUpdate,\n) -> Any:\n    \"\"\"\n    Update a user.\n    \"\"\"\n\n    db_user = session.get(User, user_id)\n    if not db_user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this id does not exist in the system\",\n        )\n    if user_in.email:\n        existing_user = crud.get_user_by_email(session=session, email=user_in.email)\n        if existing_user and existing_user.id != user_id:\n            raise HTTPException(\n                status_code=409, detail=\"User with this email already exists\"\n            )\n\n    db_user = crud.update_user(session=session, db_user=db_user, user_in=user_in)\n    return db_user",
      "get_user_by_email": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
      "authenticate": "def authenticate(*, session: Session, email: str, password: str) -> User | None:\n    db_user = get_user_by_email(session=session, email=email)\n    if not db_user:\n        return None\n    if not verify_password(password, db_user.hashed_password):\n        return None\n    return db_user",
      "create_item": "def create_item(\n    *, session: SessionDep, current_user: CurrentUser, item_in: ItemCreate\n) -> Any:\n    \"\"\"\n    Create new item.\n    \"\"\"\n    item = Item.model_validate(item_in, update={\"owner_id\": current_user.id})\n    session.add(item)\n    session.commit()\n    session.refresh(item)\n    return item",
      "init_db": "def init_db(session: Session) -> None:\n    # Tables should be created with Alembic migrations\n    # But if you don't want to use migrations, create\n    # the tables un-commenting the next lines\n    # from sqlmodel import SQLModel\n\n    # from app.core.engine import engine\n    # This works because the models are already imported and registered from app.models\n    # SQLModel.metadata.create_all(engine)\n\n    user = session.exec(\n        select(User).where(User.email == settings.FIRST_SUPERUSER)\n    ).first()\n    if not user:\n        user_in = UserCreate(\n            email=settings.FIRST_SUPERUSER,\n            password=settings.FIRST_SUPERUSER_PASSWORD,\n            is_superuser=True,\n        )\n        user = crud.create_user(session=session, user_create=user_in)",
      "parse_cors": "def parse_cors(v: Any) -> list[str] | str:\n    if isinstance(v, str) and not v.startswith(\"[\"):\n        return [i.strip() for i in v.split(\",\")]\n    elif isinstance(v, list | str):\n        return v\n    raise ValueError(v)",
      "server_host": "def server_host(self) -> str:\n        # Use HTTPS for anything other than local development\n        if self.ENVIRONMENT == \"local\":\n            return f\"http://{self.DOMAIN}\"\n        return f\"https://{self.DOMAIN}\"",
      "SQLALCHEMY_DATABASE_URI": "def SQLALCHEMY_DATABASE_URI(self) -> PostgresDsn:\n        return MultiHostUrl.build(\n            scheme=\"postgresql+psycopg\",\n            username=self.POSTGRES_USER,\n            password=self.POSTGRES_PASSWORD,\n            host=self.POSTGRES_SERVER,\n            port=self.POSTGRES_PORT,\n            path=self.POSTGRES_DB,\n        )",
      "_set_default_emails_from": "def _set_default_emails_from(self) -> Self:\n        if not self.EMAILS_FROM_NAME:\n            self.EMAILS_FROM_NAME = self.PROJECT_NAME\n        return self",
      "emails_enabled": "def emails_enabled(self) -> bool:\n        return bool(self.SMTP_HOST and self.EMAILS_FROM_EMAIL)",
      "_check_default_secret": "def _check_default_secret(self, var_name: str, value: str | None) -> None:\n        if value == \"changethis\":\n            message = (\n                f'The value of {var_name} is \"changethis\", '\n                \"for security, please change it, at least for deployments.\"\n            )\n            if self.ENVIRONMENT == \"local\":\n                warnings.warn(message, stacklevel=1)\n            else:\n                raise ValueError(message)",
      "_enforce_non_default_secrets": "def _enforce_non_default_secrets(self) -> Self:\n        self._check_default_secret(\"SECRET_KEY\", self.SECRET_KEY)\n        self._check_default_secret(\"POSTGRES_PASSWORD\", self.POSTGRES_PASSWORD)\n        self._check_default_secret(\n            \"FIRST_SUPERUSER_PASSWORD\", self.FIRST_SUPERUSER_PASSWORD\n        )\n\n        return self",
      "create_access_token": "def create_access_token(subject: str | Any, expires_delta: timedelta) -> str:\n    expire = datetime.utcnow() + expires_delta\n    to_encode = {\"exp\": expire, \"sub\": str(subject)}\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt",
      "verify_password": "def verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)",
      "get_password_hash": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)",
      "get_db": "def get_db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        yield session",
      "get_current_user": "def get_current_user(session: SessionDep, token: TokenDep) -> User:\n    try:\n        payload = jwt.decode(\n            token, settings.SECRET_KEY, algorithms=[security.ALGORITHM]\n        )\n        token_data = TokenPayload(**payload)\n    except (JWTError, ValidationError):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials\",\n        )\n    user = session.get(User, token_data.sub)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    if not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return user",
      "get_current_active_superuser": "def get_current_active_superuser(current_user: CurrentUser) -> User:\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=400, detail=\"The user doesn't have enough privileges\"\n        )\n    return current_user",
      "read_users": "def read_users(session: SessionDep, skip: int = 0, limit: int = 100) -> Any:\n    \"\"\"\n    Retrieve users.\n    \"\"\"\n\n    count_statement = select(func.count()).select_from(User)\n    count = session.exec(count_statement).one()\n\n    statement = select(User).offset(skip).limit(limit)\n    users = session.exec(statement).all()\n\n    return UsersPublic(data=users, count=count)",
      "update_user_me": "def update_user_me(\n    *, session: SessionDep, user_in: UserUpdateMe, current_user: CurrentUser\n) -> Any:\n    \"\"\"\n    Update own user.\n    \"\"\"\n\n    if user_in.email:\n        existing_user = crud.get_user_by_email(session=session, email=user_in.email)\n        if existing_user and existing_user.id != current_user.id:\n            raise HTTPException(\n                status_code=409, detail=\"User with this email already exists\"\n            )\n    user_data = user_in.model_dump(exclude_unset=True)\n    current_user.sqlmodel_update(user_data)\n    session.add(current_user)\n    session.commit()\n    session.refresh(current_user)\n    return current_user",
      "update_password_me": "def update_password_me(\n    *, session: SessionDep, body: UpdatePassword, current_user: CurrentUser\n) -> Any:\n    \"\"\"\n    Update own password.\n    \"\"\"\n    if not verify_password(body.current_password, current_user.hashed_password):\n        raise HTTPException(status_code=400, detail=\"Incorrect password\")\n    if body.current_password == body.new_password:\n        raise HTTPException(\n            status_code=400, detail=\"New password cannot be the same as the current one\"\n        )\n    hashed_password = get_password_hash(body.new_password)\n    current_user.hashed_password = hashed_password\n    session.add(current_user)\n    session.commit()\n    return Message(message=\"Password updated successfully\")",
      "read_user_me": "def read_user_me(current_user: CurrentUser) -> Any:\n    \"\"\"\n    Get current user.\n    \"\"\"\n    return current_user",
      "register_user": "def register_user(session: SessionDep, user_in: UserRegister) -> Any:\n    \"\"\"\n    Create new user without the need to be logged in.\n    \"\"\"\n    if not settings.USERS_OPEN_REGISTRATION:\n        raise HTTPException(\n            status_code=403,\n            detail=\"Open user registration is forbidden on this server\",\n        )\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system\",\n        )\n    user_create = UserCreate.model_validate(user_in)\n    user = crud.create_user(session=session, user_create=user_create)\n    return user",
      "read_user_by_id": "def read_user_by_id(\n    user_id: int, session: SessionDep, current_user: CurrentUser\n) -> Any:\n    \"\"\"\n    Get a specific user by id.\n    \"\"\"\n    user = session.get(User, user_id)\n    if user == current_user:\n        return user\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=403,\n            detail=\"The user doesn't have enough privileges\",\n        )\n    return user",
      "delete_user": "def delete_user(\n    session: SessionDep, current_user: CurrentUser, user_id: int\n) -> Message:\n    \"\"\"\n    Delete a user.\n    \"\"\"\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    elif user != current_user and not current_user.is_superuser:\n        raise HTTPException(\n            status_code=403, detail=\"The user doesn't have enough privileges\"\n        )\n    elif user == current_user and current_user.is_superuser:\n        raise HTTPException(\n            status_code=403, detail=\"Super users are not allowed to delete themselves\"\n        )\n\n    statement = delete(Item).where(col(Item.owner_id) == user_id)\n    session.exec(statement)  # type: ignore\n    session.delete(user)\n    session.commit()\n    return Message(message=\"User deleted successfully\")",
      "test_email": "def test_email(email_to: EmailStr) -> Message:\n    \"\"\"\n    Test emails.\n    \"\"\"\n    email_data = generate_test_email(email_to=email_to)\n    send_email(\n        email_to=email_to,\n        subject=email_data.subject,\n        html_content=email_data.html_content,\n    )\n    return Message(message=\"Test email sent\")",
      "login_access_token": "def login_access_token(\n    session: SessionDep, form_data: Annotated[OAuth2PasswordRequestForm, Depends()]\n) -> Token:\n    \"\"\"\n    OAuth2 compatible token login, get an access token for future requests\n    \"\"\"\n    user = crud.authenticate(\n        session=session, email=form_data.username, password=form_data.password\n    )\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    return Token(\n        access_token=security.create_access_token(\n            user.id, expires_delta=access_token_expires\n        )\n    )",
      "test_token": "def test_token(current_user: CurrentUser) -> Any:\n    \"\"\"\n    Test access token\n    \"\"\"\n    return current_user",
      "recover_password": "def recover_password(email: str, session: SessionDep) -> Message:\n    \"\"\"\n    Password Recovery\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this email does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    email_data = generate_reset_password_email(\n        email_to=user.email, email=email, token=password_reset_token\n    )\n    send_email(\n        email_to=user.email,\n        subject=email_data.subject,\n        html_content=email_data.html_content,\n    )\n    return Message(message=\"Password recovery email sent\")",
      "reset_password": "def reset_password(session: SessionDep, body: NewPassword) -> Message:\n    \"\"\"\n    Reset password\n    \"\"\"\n    email = verify_password_reset_token(token=body.token)\n    if not email:\n        raise HTTPException(status_code=400, detail=\"Invalid token\")\n    user = crud.get_user_by_email(session=session, email=email)\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this email does not exist in the system.\",\n        )\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    hashed_password = get_password_hash(password=body.new_password)\n    user.hashed_password = hashed_password\n    session.add(user)\n    session.commit()\n    return Message(message=\"Password updated successfully\")",
      "recover_password_html_content": "def recover_password_html_content(email: str, session: SessionDep) -> Any:\n    \"\"\"\n    HTML Content for Password Recovery\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    email_data = generate_reset_password_email(\n        email_to=user.email, email=email, token=password_reset_token\n    )\n\n    return HTMLResponse(\n        content=email_data.html_content, headers={\"subject:\": email_data.subject}\n    )",
      "read_items": "def read_items(\n    session: SessionDep, current_user: CurrentUser, skip: int = 0, limit: int = 100\n) -> Any:\n    \"\"\"\n    Retrieve items.\n    \"\"\"\n\n    if current_user.is_superuser:\n        count_statement = select(func.count()).select_from(Item)\n        count = session.exec(count_statement).one()\n        statement = select(Item).offset(skip).limit(limit)\n        items = session.exec(statement).all()\n    else:\n        count_statement = (\n            select(func.count())\n            .select_from(Item)\n            .where(Item.owner_id == current_user.id)\n        )\n        count = session.exec(count_statement).one()\n        statement = (\n            select(Item)\n            .where(Item.owner_id == current_user.id)\n            .offset(skip)\n            .limit(limit)\n        )\n        items = session.exec(statement).all()\n\n    return ItemsPublic(data=items, count=count)",
      "read_item": "def read_item(session: SessionDep, current_user: CurrentUser, id: int) -> Any:\n    \"\"\"\n    Get item by ID.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    return item",
      "update_item": "def update_item(\n    *, session: SessionDep, current_user: CurrentUser, id: int, item_in: ItemUpdate\n) -> Any:\n    \"\"\"\n    Update an item.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    update_dict = item_in.model_dump(exclude_unset=True)\n    item.sqlmodel_update(update_dict)\n    session.add(item)\n    session.commit()\n    session.refresh(item)\n    return item",
      "delete_item": "def delete_item(session: SessionDep, current_user: CurrentUser, id: int) -> Message:\n    \"\"\"\n    Delete an item.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    session.delete(item)\n    session.commit()\n    return Message(message=\"Item deleted successfully\")",
      "get_url": "def get_url():\n    user = os.getenv(\"POSTGRES_USER\", \"postgres\")\n    password = os.getenv(\"POSTGRES_PASSWORD\", \"\")\n    server = os.getenv(\"POSTGRES_SERVER\", \"db\")\n    port = os.getenv(\"POSTGRES_PORT\", \"5432\")\n    db = os.getenv(\"POSTGRES_DB\", \"app\")\n    return f\"postgresql+psycopg://{user}:{password}@{server}:{port}/{db}\"",
      "run_migrations_offline": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = get_url()\n    context.configure(\n        url=url, target_metadata=target_metadata, literal_binds=True, compare_type=True\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()",
      "run_migrations_online": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    configuration = config.get_section(config.config_ini_section)\n    configuration[\"sqlalchemy.url\"] = get_url()\n    connectable = engine_from_config(\n        configuration,\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata, compare_type=True\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()",
      "upgrade": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"user\",\n        sa.Column(\"email\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"is_active\", sa.Boolean(), nullable=False),\n        sa.Column(\"is_superuser\", sa.Boolean(), nullable=False),\n        sa.Column(\"full_name\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\n            \"hashed_password\", sqlmodel.sql.sqltypes.AutoString(), nullable=False\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_user_email\"), \"user\", [\"email\"], unique=True)\n    op.create_table(\n        \"item\",\n        sa.Column(\"description\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"title\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"owner_id\", sa.Integer(), nullable=False),\n        sa.ForeignKeyConstraint(\n            [\"owner_id\"],\n            [\"user.id\"],\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )",
      "downgrade": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table(\"item\")\n    op.drop_index(op.f(\"ix_user_email\"), table_name=\"user\")\n    op.drop_table(\"user\")"
    },
    "class_to_code": {
      "UserBase": [],
      "UserCreate": [],
      "UserRegister": [],
      "UserUpdate": [],
      "UserUpdateMe": [],
      "UpdatePassword": [],
      "User": [],
      "UserPublic": [],
      "UsersPublic": [],
      "ItemBase": [],
      "ItemCreate": [],
      "ItemUpdate": [],
      "Item": [],
      "ItemPublic": [],
      "ItemsPublic": [],
      "Message": [],
      "Token": [],
      "TokenPayload": [],
      "NewPassword": [],
      "EmailData": [],
      "Settings": []
    },
    "function_to_test": {
      "Session": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "init_db": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "delete": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "session.execute": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "session.commit": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "pytest.fixture": [
        "def normal_user_token_headers(client: TestClient, db: Session) -> dict[str, str]:\n    return authentication_token_from_email(\n        client=client, email=settings.EMAIL_TEST_USER, db=db\n    )"
      ],
      "TestClient": [
        "def client() -> Generator[TestClient, None, None]:\n    with TestClient(app) as c:\n        yield c"
      ],
      "get_superuser_token_headers": [
        "def superuser_token_headers(client: TestClient) -> dict[str, str]:\n    return get_superuser_token_headers(client)"
      ],
      "authentication_token_from_email": [
        "def normal_user_token_headers(client: TestClient, db: Session) -> dict[str, str]:\n    return authentication_token_from_email(\n        client=client, email=settings.EMAIL_TEST_USER, db=db\n    )"
      ],
      "client.post": [
        "def user_authentication_headers(\n    *, client: TestClient, email: str, password: str\n) -> dict[str, str]:\n    data = {\"username\": email, \"password\": password}\n\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=data)\n    response = r.json()\n    auth_token = response[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    return headers",
        "def get_superuser_token_headers(client: TestClient) -> dict[str, str]:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n    return headers",
        "def test_reset_password_invalid_token(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"new_password\": \"changethis\", \"token\": \"invalid\"}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    response = r.json()\n\n    assert \"detail\" in response\n    assert r.status_code == 400\n    assert response[\"detail\"] == \"Invalid token\"",
        "def test_create_item(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"title\": \"Foo\", \"description\": \"Fighters\"}\n    response = client.post(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert content[\"title\"] == data[\"title\"]\n    assert content[\"description\"] == data[\"description\"]\n    assert \"id\" in content\n    assert \"owner_id\" in content",
        "def test_delete_user_current_user(client: TestClient, db: Session) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_id = user.id\n\n    login_data = {\n        \"username\": username,\n        \"password\": password,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=headers,\n    )\n    assert r.status_code == 200\n    deleted_user = r.json()\n    assert deleted_user[\"message\"] == \"User deleted successfully\""
      ],
      "r.json": [
        "def user_authentication_headers(\n    *, client: TestClient, email: str, password: str\n) -> dict[str, str]:\n    data = {\"username\": email, \"password\": password}\n\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=data)\n    response = r.json()\n    auth_token = response[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    return headers",
        "def get_superuser_token_headers(client: TestClient) -> dict[str, str]:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n    return headers",
        "def test_reset_password_invalid_token(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"new_password\": \"changethis\", \"token\": \"invalid\"}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    response = r.json()\n\n    assert \"detail\" in response\n    assert r.status_code == 400\n    assert response[\"detail\"] == \"Invalid token\"",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "random_email": [
        "def create_random_user(db: Session) -> User:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    return user",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "random_lower_string": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def random_email() -> str:\n    return f\"{random_lower_string()}@{random_lower_string()}.com\"",
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "UserCreate": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "crud.create_user": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "crud.get_user_by_email": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_delete_user_current_super_user_error(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    super_user = crud.get_user_by_email(session=db, email=settings.FIRST_SUPERUSER)\n    assert super_user\n    user_id = super_user.id\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=superuser_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"Super users are not allowed to delete themselves\""
      ],
      "UserUpdate": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "Exception": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)"
      ],
      "crud.update_user": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "user_authentication_headers": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)"
      ],
      "random.choices": [
        "def random_lower_string() -> str:\n    return \"\".join(random.choices(string.ascii_lowercase, k=32))"
      ],
      "create_random_user": [
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)"
      ],
      "ItemCreate": [
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)"
      ],
      "crud.create_item": [
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)"
      ],
      "MagicMock": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "session_mock.configure_mock": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "patch": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_recovery_password(\n    client: TestClient, normal_user_token_headers: dict[str, str]\n) -> None:\n    with (\n        patch(\"app.core.config.settings.SMTP_HOST\", \"smtp.example.com\"),\n        patch(\"app.core.config.settings.SMTP_USER\", \"admin@example.com\"),\n    ):\n        email = \"test@example.com\"\n        r = client.post(\n            f\"{settings.API_V1_STR}/password-recovery/{email}\",\n            headers=normal_user_token_headers,\n        )\n        assert r.status_code == 200\n        assert r.json() == {\"message\": \"Password recovery email sent\"}",
        "def test_register_user_already_exists_error(client: TestClient) -> None:\n    with patch(\"app.core.config.settings.USERS_OPEN_REGISTRATION\", True):\n        password = random_lower_string()\n        full_name = random_lower_string()\n        data = {\n            \"email\": settings.FIRST_SUPERUSER,\n            \"password\": password,\n            \"full_name\": full_name,\n        }\n        r = client.post(\n            f\"{settings.API_V1_STR}/users/signup\",\n            json=data,\n        )\n        assert r.status_code == 400\n        assert (\n            r.json()[\"detail\"]\n            == \"The user with this email already exists in the system\"\n        )"
      ],
      "patch.object": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "init": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "select": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "hasattr": [
        "def test_create_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    assert user.email == email\n    assert hasattr(user, \"hashed_password\")"
      ],
      "crud.authenticate": [
        "def test_not_authenticate_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user = crud.authenticate(session=db, email=email, password=password)\n    assert user is None"
      ],
      "db.get": [
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "jsonable_encoder": [
        "def test_get_user(db: Session) -> None:\n    password = random_lower_string()\n    username = random_email()\n    user_in = UserCreate(email=username, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert jsonable_encoder(user) == jsonable_encoder(user_2)"
      ],
      "verify_password": [
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "generate_password_reset_token": [
        "def test_reset_password(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    token = generate_password_reset_token(email=settings.FIRST_SUPERUSER)\n    data = {\"new_password\": \"changethis\", \"token\": token}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    assert r.json() == {\"message\": \"Password updated successfully\"}"
      ],
      "response.json": [
        "def test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\""
      ],
      "create_random_item": [
        "def test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\""
      ],
      "client.get": [
        "def test_read_items(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    create_random_item(db)\n    create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert len(content[\"data\"]) >= 2",
        "def test_retrieve_users(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    crud.create_user(session=db, user_create=user_in2)\n\n    r = client.get(f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers)\n    all_users = r.json()\n\n    assert len(all_users[\"data\"]) > 1\n    assert \"count\" in all_users\n    for item in all_users[\"data\"]:\n        assert \"email\" in item"
      ],
      "len": [
        "def test_read_items(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    create_random_item(db)\n    create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert len(content[\"data\"]) >= 2",
        "def test_retrieve_users(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    crud.create_user(session=db, user_create=user_in2)\n\n    r = client.get(f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers)\n    all_users = r.json()\n\n    assert len(all_users[\"data\"]) > 1\n    assert \"count\" in all_users\n    for item in all_users[\"data\"]:\n        assert \"email\" in item"
      ],
      "client.put": [
        "def test_update_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    data = {\"title\": \"Updated title\", \"description\": \"Updated description\"}\n    response = client.put(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n        json=data,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\""
      ],
      "client.delete": [
        "def test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\"",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "client.patch": [
        "def test_update_user_email_exists(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    user2 = crud.create_user(session=db, user_create=user_in2)\n\n    data = {\"email\": user2.email}\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 409\n    assert r.json()[\"detail\"] == \"User with this email already exists\""
      ]
    },
    "files": [],
    "readme": {
      "text": "# FastAPI Project - Backend\n\n## Requirements\n\n* [Docker](https://www.docker.com/).\n* [Poetry](https://python-poetry.org/) for Python package and environment management.\n\n## Local Development\n\n* Start the stack with Docker Compose:\n\n```bash\ndocker compose up -d\n```\n\n* Now you can open your browser and interact with these URLs:\n\nFrontend, built with Docker, with routes handled based on the path: http://localhost\n\nBackend, JSON based web API based on OpenAPI: http://localhost/api/\n\nAutomatic interactive documentation with Swagger UI (from the OpenAPI backend): http://localhost/docs\n\nAdminer, database web administration: http://localhost:8080\n\nTraefik UI, to see how the routes are being handled by the proxy: http://localhost:8090\n\n**Note**: The first time you start your stack, it might take a minute for it to be ready. While the backend waits for the database to be ready and configures everything. You can check the logs to monitor it.\n\nTo check the logs, run:\n\n```bash\ndocker compose logs\n```\n\nTo check the logs of a specific service, add the name of the service, e.g.:\n\n```bash\ndocker compose logs backend\n```\n\nIf your Docker is not running in `localhost` (the URLs above wouldn't work) you would need to use the IP or domain where your Docker is running.\n\n## Backend local development, additional details\n\n### General workflow\n\nBy default, the dependencies are managed with [Poetry](https://python-poetry.org/), go there and install it.\n\nFrom `./backend/` you can install all the dependencies with:\n\n```console\n$ poetry install\n```\n\nThen you can start a shell session with the new environment with:\n\n```console\n$ poetry shell\n```\n\nMake sure your editor is using the correct Python virtual environment.\n\nModify or add SQLModel models for data and SQL tables in `./backend/app/models.py`, API endpoints in `./backend/app/api/`, CRUD (Create, Read, Update, Delete) utils in `./backend/app/crud.py`.\n\n### VS Code\n\nThere are already configurations in place to run the backend through the VS Code debugger, so that you can use breakpoints, pause and explore variables, etc.\n\nThe setup is also already configured so you can run the tests through the VS Code Python tests tab.\n\n### Docker Compose Override\n\nDuring development, you can change Docker Compose settings that will only affect the local development environment in the file `docker-compose.override.yml`.\n\nThe changes to that file only affect the local development environment, not the production environment. So, you can add \"temporary\" changes that help the development workflow.\n\nFor example, the directory with the backend code is mounted as a Docker \"host volume\", mapping the code you change live to the directory inside the container. That allows you to test your changes right away, without having to build the Docker image again. It should only be done during development, for production, you should build the Docker image with a recent version of the backend code. But during development, it allows you to iterate very fast.\n\nThere is also a command override that runs `/start-reload.sh` (included in the base image) instead of the default `/start.sh` (also included in the base image). It starts a single server process (instead of multiple, as would be for production) and reloads the process whenever the code changes. Have in mind that if you have a syntax error and save the Python file, it will break and exit, and the container will stop. After that, you can restart the container by fixing the error and running again:\n\n```console\n$ docker compose up -d\n```\n\nThere is also a commented out `command` override, you can uncomment it and comment the default one. It makes the backend container run a process that does \"nothing\", but keeps the container alive. That allows you to get inside your running container and execute commands inside, for example a Python interpreter to test installed dependencies, or start the development server that reloads when it detects changes.\n\nTo get inside the container with a `bash` session you can start the stack with:\n\n```console\n$ docker compose up -d\n```\n\nand then `exec` inside the running container:\n\n```console\n$ docker compose exec backend bash\n```\n\nYou should see an output like:\n\n```console\nroot@7f2607af31c3:/app#\n```\n\nthat means that you are in a `bash` session inside your container, as a `root` user, under the `/app` directory, this directory has another directory called \"app\" inside, that's where your code lives inside the container: `/app/app`.\n\nThere you can use the script `/start-reload.sh` to run the debug live reloading server. You can run that script from inside the container with:\n\n```console\n$ bash /start-reload.sh\n```\n\n...it will look like:\n\n```console\nroot@7f2607af31c3:/app# bash /start-reload.sh\n```\n\nand then hit enter. That runs the live reloading server that auto reloads when it detects code changes.\n\nNevertheless, if it doesn't detect a change but a syntax error, it will just stop with an error. But as the container is still alive and you are in a Bash session, you can quickly restart it after fixing the error, running the same command (\"up arrow\" and \"Enter\").\n\n...this previous detail is what makes it useful to have the container alive doing nothing and then, in a Bash session, make it run the live reload server.\n\n### Backend tests\n\nTo test the backend run:\n\n```console\n$ bash ./scripts/test.sh\n```\n\nThe tests run with Pytest, modify and add tests to `./backend/app/tests/`.\n\nIf you use GitHub Actions the tests will run automatically.\n\n#### Test running stack\n\nIf your stack is already up and you just want to run the tests, you can use:\n\n```bash\ndocker compose exec backend bash /app/tests-start.sh\n```\n\nThat `/app/tests-start.sh` script just calls `pytest` after making sure that the rest of the stack is running. If you need to pass extra arguments to `pytest`, you can pass them to that command and they will be forwarded.\n\nFor example, to stop on first error:\n\n```bash\ndocker compose exec backend bash /app/tests-start.sh -x\n```\n\n#### Test Coverage\n\nWhen the tests are run, a file `htmlcov/index.html` is generated, you can open it in your browser to see the coverage of the tests.\n\n### Migrations\n\nAs during local development your app directory is mounted as a volume inside the container, you can also run the migrations with `alembic` commands inside the container and the migration code will be in your app directory (instead of being only inside the container). So you can add it to your git repository.\n\nMake sure you create a \"revision\" of your models and that you \"upgrade\" your database with that revision every time you change them. As this is what will update the tables in your database. Otherwise, your application will have errors.\n\n* Start an interactive session in the backend container:\n\n```console\n$ docker compose exec backend bash\n```\n\n* Alembic is already configured to import your SQLModel models from `./backend/app/models.py`.\n\n* After changing a model (for example, adding a column), inside the container, create a revision, e.g.:\n\n```console\n$ alembic revision --autogenerate -m \"Add column last_name to User model\"\n```\n\n* Commit to the git repository the files generated in the alembic directory.\n\n* After creating the revision, run the migration in the database (this is what will actually change the database):\n\n```console\n$ alembic upgrade head\n```\n\nIf you don't want to use migrations at all, uncomment the lines in the file at `./backend/app/core/db.py` that end in:\n\n```python\nSQLModel.metadata.create_all(engine)\n```\n\nand comment the line in the file `prestart.sh` that contains:\n\n```console\n$ alembic upgrade head\n```\n\nIf you don't want to start with the default models and want to remove them / modify them, from the beginning, without having any previous revision, you can remove the revision files (`.py` Python files) under `./backend/app/alembic/versions/`. And then create a first migration as described above.\n\n\nGeneric single-database configuration.\n\n\n",
      "summary": "# FastAPI Project - Backend\n\nThis project is a backend developed using FastAPI. It requires Docker and Poetry for Python package and environment management.\n\n## Key Features\n\n- Frontend built with Docker, with routes handled based on the path.\n- Backend, JSON based web API based on OpenAPI.\n- Automatic interactive documentation with Swagger UI.\n- Adminer for database web administration.\n- Traefik UI to monitor how routes are handled by the proxy.\n\n## Local Development\n\nTo start the stack, use Docker Compose with the command `docker compose up -d`. The first time you start your stack, it might take a minute for it to be ready. You can check the logs to monitor it using `docker compose logs`.\n\n## Backend Local Development\n\nDependencies are managed with Poetry. You can install all the dependencies from `./backend/` using `poetry install` and start a shell session with the new environment using `poetry shell`.\n\nYou can modify or add SQLModel models for data and SQL tables in `./backend/app/models.py`, API endpoints in `./backend/app/api/`, CRUD utils in `./backend/app/crud.py`.\n\nVS Code configurations are in place to run the backend through the VS Code debugger and run the tests through the VS Code Python tests tab.\n\n## Docker Compose Override\n\nDuring development, you can change Docker Compose settings that will only affect the local development environment in the file `docker-compose.override.yml`.\n\n## Backend Tests\n\nTo test the backend, run `bash ./scripts/test.sh`. The tests run with Pytest, modify and add tests to `./backend/app/tests/`.\n\n## Migrations\n\nAfter changing a model, create a revision using Alembic and run the migration in the database. This will update the tables in your database. If you don't want to use migrations, you can modify the files in `./backend/app/core/db.py` and `prestart.sh`.\n\n## Contribution\n\nThe README does not provide specific contribution guidelines. However, given the detailed instructions for local development and testing, contributors should be able to set up the project locally and make contributions as needed."
    },
    "functions": [
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "This Python function, named `get_user_by_email`, takes in a SQLAlchemy session and an email as arguments, marked with the `*` decorator to indicate keyword-only parameters. It returns either a `User` object or `None` after searching for the user with the given email using a SQLAlchemy query with the `select()` function. The user is retrieved from the session using `exec()`, and its value is assigned to the variable `session_user`. Finally, the `return` statement sends back either the found `User` or `None`. In summary, this function allows finding a specific user based on their email address in SQLAlchemy.",
        "code_with_comments": "\nThe system will generate the following commented code based on the analysis of the function:\n```\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    \"\"\"\n    Returns the user with the given email address, or None if no such user exists.\n    \n    Parameters:\n    -----------\n    * `session`: The SQLAlchemy session object to use for querying the database.\n    - `email`: The email address of the user to retrieve.\n    \n    Returns:\n    --------\n    A User object if a user with the given email exists, or None otherwise.\n    \"\"\"\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n```",
        "test": " "
      },
      {
        "name": "create_user",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/api/routes/users.py",
        "code": "def create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    return user",
        "summary": "The Python function `create_user` creates a new user when called with arguments `session` and `user_in`. If a user with the same email address already exists in the system, an HTTPException is raised. Otherwise, the `crud` module's `create_user` function is invoked to add the new user to the database. If email notifications are enabled and a valid email address was provided for the new user, a new account confirmation email is generated using the `generate_new_account_email` function and sent to the email address provided by the user. The completed user object is then returned.",
        "code_with_comments": "\nThe function `create_user` takes in two parameters: `session` and `user_in`. The `session` parameter is of type `SessionDep`, while the `user_in` parameter is of type `UserCreate`. The function returns an `Any` value.\n\nHere's a commented version of the function based on the analysis:\n```\ndef create_user(\n    # Session object used for CRUD operations\n    session: SessionDep, \n    \n    # User creation input data\n    user_in: UserCreate, \n):\n    \"\"\"\n    Create new user.\n    \"\"\"\n    # Check if a user with the same email already exists in the system\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400, \n            detail=\"The user with this email already exists in the system.\", \n        )\n    \n    # Create new user and return it\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        # Generate email data for the new account\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.username, password=user_in.password\n        )\n        \n        # Send email to new user with account details\n        send_email(\n            email_to=user_in.email, \n            subject=email_data.subject, \n            html_content=email_data.html_content, \n        )\n    \n    return user\n```",
        "test": " "
      },
      {
        "name": "generate_new_account_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_new_account_email(\n    email_to: str, username: str, password: str\n) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - New account for user {username}\"\n    html_content = render_email_template(\n        template_name=\"new_account.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": settings.server_host,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
        "summary": "The Python function `generate_new_account_email` takes three arguments `email_to`, `username`, and `password`. It generates a new account email with the given information and returns an object called `EmailData` containing the HTML content and subject of the email. The email's subject is formatted using string formatting, where `project_name` comes from the `settings` module, and the username is passed as an argument. A template named `new_account.html` is rendered with the given context, which includes variables like `project_name`, `username`, `password`, `email`, and `server_host`. This function can be used to automatically send a new account confirmation email to the user's registered email address.",
        "code_with_comments": "\nThe system will parse the function and generate a commented version of it based on its analysis. The generated code will be similar to the following:\n```\n# Function that generates new account email data\ndef generate_new_account_email(\n    # Email address to send the email to\n    email_to: str,\n    # Username for the new account\n    username: str,\n    # Password for the new account\n    password: str\n) -> EmailData:\n    \"\"\"\n    This function generates a new account email data object.\n\n    Parameters:\n        email_to (str): Email address to send the email to.\n        username (str): Username for the new account.\n        password (str): Password for the new account.\n    \n    Returns:\n        EmailData: An email data object with the generated email content and subject.\n    \"\"\"\n    # Load project settings\n    settings = load_settings()\n\n    # Set the project name\n    project_name = settings.PROJECT_NAME\n\n    # Create the subject of the email\n    subject = f\"{project_name} - New account for user {username}\"\n\n    # Render the email template with the given context\n    html_content = render_email_template(\n        template_name=\"new_account.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": settings.server_host,\n        },\n    )\n\n    # Return the email data object with the generated content and subject\n    return EmailData(html_content=html_content, subject=subject)\n```\nThe system will also provide a detailed explanation of each parameter, including its purpose, type, and default value.",
        "test": " "
      },
      {
        "name": "send_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")",
        "summary": "This Python function, named `send_email`, allows sending an email with a customizable subject and body. The function takes in three arguments: the required recipient email address `email_to`, and optional arguments for the email subject (default is empty) and HTML content for the body. \n\nThe function starts by checking if there are provided configurations for email variables using the `settings` module. If not, it raises an assertion error. It then creates a new message object with the specified subject and HTML content. The sender name and email address are set from the configurations in the `settings` module. \n\nThe SMTP options are configured based on settings for TLS, SSL, host, and port, before the message is sent to the recipient using the `Message.send()` method with the specified smtp options. The function then logs the result of sending the email. Overall, this function provides a convenient way to send customizable emails from a Python application while still allowing configuration flexibility.",
        "code_with_comments": "The system will generate a commented version of the function based on its analysis of the input code. Here is an example of what the commented version of the `send_email` function might look like:\n```\ndef send_email(\n    # Send email with given parameters\n    *,\n    email_to: str,  # Email address to send email to\n    subject: str = \"\",  # Subject line of the email (optional)\n    html_content: str = \"\",  # HTML content of the email (optional)\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"  # Check if emails are enabled in the current environment\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )  # Create a new email message with the given parameters\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}  # Set up SMTP options for sending the email\n    if settings.SMTP_TLS:  # Check if TLS is enabled for SMTP\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:  # Check if SSL is enabled for SMTP\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:  # Check if a username is provided for SMTP authentication\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:  # Check if a password is provided for SMTP authentication\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)  # Send the email using the given SMTP options\n    logging.info(f\"send email result: {response}\")  # Log the result of sending the email\n```\nThis commented version includes explanatory comments for each line of code and helps users understand what the function does and how it works.",
        "test": " "
      },
      {
        "name": "get_password_hash",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)",
        "summary": "This Python function, named `get_password_hash`, takes a password as an input parameter of type string and returns its hash using the `pwd_context` module. The returned value is also of type string. This function's purpose is to securely store user passwords by hashing them before storing in a database or file system.\n\nThe `pwd_context` module is a part of the Unix cryptography libraries and is available as a Python library named 'crypt'. It provides methods for password storage using industry-standard algorithms like SHA-256, BCRYPT, and PBKDF2HMACSHA1.\n\nBy returning the hash instead of the plaintext password, this function helps in mitigating potential security risks associated with storing user passwords in plain text format.",
        "code_with_comments": "\nThe system will parse the function and identify its purpose, parameters, and return value. Based on this analysis, it will generate a commented version of the function like this:\n```\ndef get_password_hash(password: str) -> str:\n    \"\"\"\n    Generates a hashed password using the pwd_context object.\n    \n    :param password: The plaintext password to be hashed.\n    :return: The hashed password as a string.\n    \"\"\"\n    return pwd_context.hash(password)\n```\nThe commented version includes a summary of the function's purpose, a description of each parameter and its type, and a list of any exceptions that may be raised by the function. This information can be used to help other developers understand the function's behavior and usage, and to ensure that the function is used correctly and safely within the codebase.",
        "test": " "
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "The function `get_user_by_email` in Python, given an email and a database session, retrieves the user with the matching email from the database using SQLAlchemy's select statement. The returned value can be either the found user object or None if no user is found. The `*` argument syntax is used to indicate that the function can take keyword arguments, but in this specific case, it's not required as all parameters are present. This function facilitates quick and efficient retrieval of users based on their email addresses without needing to write complex SQL queries.",
        "code_with_comments": "\nHere's the commented version of the function based on the analysis of the user input:\n```\n# Retrieves a user by their email address\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    \"\"\"\n    Returns the user with the specified email address if found, otherwise returns None.\n    \n    Parameters:\n        - session (Session): The SQLAlchemy session to use for querying the database.\n        - email (str): The email address of the user to retrieve.\n    \n    Return value:\n        - User | None: The retrieved user object, or None if no user with the specified email address was found.\n    \"\"\"\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n```",
        "test": " "
      },
      {
        "name": "create_user",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/api/routes/users.py",
        "code": "def create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    return user",
        "summary": "The Python function `create_user` creates a new user using the `crud` module's `create_user` function, provided the email address of the new user is not already in use. If emails are enabled and an email address has been provided for the new user, a new account email will be generated and sent via the `send_email` function. The function returns the newly created user object. In summary, this function allows for the creation of a new user with optional email verification.",
        "code_with_comments": "\nThe system will analyze the function and generate a commented version of it based on its purpose, parameters, and return value. Here's an example of what the commented code might look like:\n```\n# create_user(session: SessionDep, user_in: UserCreate) -> Any\ndef create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \n    Parameters:\n    -----------\n    session: The database session object used for interacting with the database.\n    user_in: A dictionary containing information about the user to be created.\n    \n    Returns:\n    --------\n    Any: The created user object, or None if an error occurred.\n    \n    Raises:\n    -------\n    HTTPException(400): If a user with the same email already exists in the system.\n    \"\"\"\n    # Check if a user with the given email already exists\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n    \n    # Create the new user\n    user = crud.create_user(session=session, user_create=user_in)\n    \n    # Send a welcome email if emails are enabled and the user's email is set\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    \n    return user\n```\nNote that the commented code includes information about the function's parameters and return value, as well as any exceptions that it may raise. It also provides a brief description of the function's purpose and its expected inputs and outputs.",
        "test": " "
      },
      {
        "name": "get_password_hash",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)",
        "summary": "The given Python function is named `get_password_hash` and takes a string argument `password`. It then uses the `pwd_context` to hash the password using the `hash()` method and returns the hashed result as a string. This function seems to be used for securely storing passwords by hashing them instead of storing plain text passwords.",
        "code_with_comments": "The system parses the function to identify its purpose, parameters, and return value. Based on this analysis, it generates a commented version of the function as follows:\n```\ndef get_password_hash(password: str) -> str:  # Hashes the input password using the pwd_context object\n    \"\"\"\n    Purpose: Returns a hashed version of the input password.\n    \n    Parameters:\n        * password (str): The input password to be hashed.\n    \n    Return value:\n        A str representing the hashed password.\n    \"\"\"\n    return pwd_context.hash(password)\n```\nThe system comments on the purpose of the function, the parameters it takes in, and the return value it produces. It also provides a detailed explanation of what the function does and how it works.",
        "test": " "
      },
      {
        "name": "generate_test_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_test_email(email_to: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Test email\"\n    html_content = render_email_template(\n        template_name=\"test_email.html\",\n        context={\"project_name\": settings.PROJECT_NAME, \"email\": email_to},\n    )\n    return EmailData(html_content=html_content, subject=subject)",
        "summary": "This Python function named `generate_test_email` takes an email address (stored in the variable `email_to`) as input and returns an object of type `EmailData`. The function defines two variables `project_name` and `subject` which are initialized using the `settings.PROJECT_NAME` variable. The `html_content` is generated by rendering a template called 'test_email.html' with context values including 'project_name' and 'email'. The `EmailData` object is then returned, containing the generated HTML content and subject for the email. In summary, this function generates an email with a test message and sends it to a specified email address.",
        "code_with_comments": "[PYTHON]\ndef generate_test_email(email_to: str) -> EmailData:\n    \"\"\"\n    Generate a test email for the given recipient.\n    \n    Parameters:\n        email_to (str): The recipient's email address.\n    \n    Returns:\n        EmailData: An object containing the email data.\n    \"\"\"\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Test email\"\n    html_content = render_email_template(\n        template_name=\"test_email.html\",\n        context={\"project_name\": settings.PROJECT_NAME, \"email\": email_to},\n    )\n    return EmailData(html_content=html_content, subject=subject)\n[/PYTHON]\n\nThe system will generate the commented version of the function as follows:\n```\ndef generate_test_email(email_to: str) -> EmailData:\n    \"\"\"\n    Generate a test email for the given recipient.\n    \n    Parameters:\n        email_to (str): The recipient's email address.\n    \n    Returns:\n        EmailData: An object containing the email data.\n    \"\"\"\n```\nThe system will also provide the user with the commented code, which they can use to understand the purpose and parameters of the function, as well as its return value.",
        "test": " "
      },
      {
        "name": "send_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")",
        "summary": "The function `send_email` in Python is used to send an email with a customizable subject and optional HTML content to the specified email address. The configuration for email variables must be provided, and the function raises an assertion error if no configuration is available. The email is sent using the settings for SMTP server, port, TLS/SSL encryption, username, and password. After sending the email, a log message containing the result of the email send operation is generated. The default value for subject is an empty string (\"\").",
        "code_with_comments": "\nThe system will generate a commented version of the function based on its analysis. Here's an example of what the commented code might look like:\n```\ndef send_email(\n    # *,\n    # email_to: str,\n    # subject: str = \"\",\n    # html_content: str = \"\",\n) -> None:\n    \"\"\"Sends an email with the specified parameters.\n\n    Args:\n        email_to (str): The recipient's email address.\n        subject (str, optional): The subject line of the email. Defaults to \"\".\n        html_content (str, optional): The HTML content of the email. Defaults to \"\".\n\n    Returns:\n        None: No return value.\n\n    Raises:\n        AssertionError: If the configuration for email variables is not provided.\n    \"\"\"\n    # Check if email variables are configured\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n\n    # Create an email message\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n\n    # Set the SMTP options\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n\n    # Send the email using the SMTP options\n    response = message.send(to=email_to, smtp=smtp_options)\n\n    # Log the result of sending the email\n    logging.info(f\"send email result: {response}\")\n```",
        "test": " "
      },
      {
        "name": "authenticate",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def authenticate(*, session: Session, email: str, password: str) -> User | None:\n    db_user = get_user_by_email(session=session, email=email)\n    if not db_user:\n        return None\n    if not verify_password(password, db_user.hashed_password):\n        return None\n    return db_user",
        "summary": "The `authenticate` function in Python takes two arguments, `session` and `email`, as well as optional keyword arguments `password` and returns a `User` object or `None`. The function retrieves the user with the given email from the database using `get_user_by_email()` and checks if their password is correct using `verify_password()`. If either check fails, the function returns `None`, indicating an unsuccessful login attempt. Otherwise, it returns the `User` object. This function seems to be responsible for authenticating a user based on their email and password.",
        "code_with_comments": "```\ndef authenticate(*, session: Session, email: str, password: str) -> User | None:\n    \"\"\"Authenticates a user using their email and password.\n    \n    Args:\n        session (Session): The current session.\n        email (str): The user's email address.\n        password (str): The user's password.\n    \n    Returns:\n        User | None: The authenticated user, or None if authentication failed.\n    \"\"\"\n    db_user = get_user_by_email(session=session, email=email)\n    if not db_user:\n        return None\n    if not verify_password(password, db_user.hashed_password):\n        return None\n    return db_user\n```",
        "test": " "
      },
      {
        "name": "create_access_token",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def create_access_token(subject: str | Any, expires_delta: timedelta) -> str:\n    expire = datetime.utcnow() + expires_delta\n    to_encode = {\"exp\": expire, \"sub\": str(subject)}\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt",
        "summary": "The Python function `create_access_token` takes in a subject and an expiration time duration as arguments and generates a JSON Web Token (JWT) using the PyJWT library. The JWT is encoded with the secret key provided by the `settings` module, and includes the subject and expiration time in its payload. The function returns the generated JWT as a string.",
        "code_with_comments": "  Here is the commented version of the function:\n```\ndef create_access_token(subject: str | Any, expires_delta: timedelta) -> str:\n    \"\"\"\n    This function creates an access token for a given subject and expiry time.\n\n    Args:\n        subject (str | Any): The subject of the access token. Can be any type that is compatible with the `str` type.\n        expires_delta (timedelta): The duration after which the access token should expire.\n\n    Returns:\n        str: The encoded JWT token for the given subject and expiry time.\n    \"\"\"\n    # Generate a UTC timestamp for the expiration of the access token\n    expire = datetime.utcnow() + expires_delta\n\n    # Create a dictionary to encode with the JWT library\n    to_encode = {\"exp\": expire, \"sub\": str(subject)}\n\n    # Encode the dictionary with the JWT library and return the encoded token\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n```",
        "test": " "
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "The Python function `get_user_by_email` takes a `session` object and an email address as arguments. It uses the SQLAlchemy `select` function to retrieve the user with the given email from the database, stored in the `User` class. The returned value is either the retrieved `User` object or `None` if no user was found. This function can be used to quickly and efficiently search for a specific user based on their email address without the need to write a more complex SQL query.",
        "code_with_comments": "  ```\n# Function to retrieve a user by their email address\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    # This function takes in a SQLAlchemy session and an email address as input\n    # It returns the user object if found, or None otherwise\n    \n    # Statement to select the user with the given email address from the database\n    statement = select(User).where(User.email == email)\n    \n    # Execute the statement on the SQLAlchemy session to retrieve the user object\n    session_user = session.exec(statement).first()\n    \n    return session_user\n```",
        "test": " "
      },
      {
        "name": "verify_password",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)",
        "summary": "The `verify_password` function in Python takes two arguments, `plain_password` (a plaintext password) and `hashed_password` (a hash value of a previously stored password), both of which are passed as strings. This function then uses an instance of the `pwd_context` class to verify whether the `plain_password` matches the `hashed_password`. If the passwords match, the function returns `True`, indicating that the user has entered the correct password; otherwise, it returns `False`. The `pwd_context` class is a part of the standard library's `cryptography.fernet` module and provides methods for working with symmetric-key cryptography.",
        "code_with_comments": "  ```\n# Verify password function\n#\n# Purpose: This function verifies if a plain password matches the stored hashed password\n#\n# Parameters:\n#   * plain_password (str): The plain password that needs to be verified\n#   * hashed_password (str): The stored hashed password that needs to be matched with the plain password\n#\n# Return value:\n#   * bool: Whether the plain password matches the stored hashed password or not\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n```",
        "test": [
          "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
        ]
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "The function `get_user_by_email` in Python is a method that retrieves a user with the specified email address from a database using the SQLAlchemy library's Session object. The function takes two arguments, `session` (a connection to the database) and `email` (the email address of the user to search for), both marked as keyword arguments (*). \n\nThe function starts by defining a query statement using the `select()` method from SQLAlchemy's Query object. This statement selects all columns from the `User` table where the `email` column matches the provided value. The statement is then executed using the `exec()` method, and the first result is returned as the `session_user` variable.\n\nThe function returns either the retrieved user (if found) or `None` if no user with the specified email address exists in the database.",
        "code_with_comments": "\nHere is the commented version of the `get_user_by_email` function based on the analysis:\n```\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    \"\"\"\n    Retrieves a user by their email address.\n    \n    Parameters:\n        session (Session): The database session to use for the query.\n        email (str): The email address of the user to retrieve.\n    \n    Returns:\n        User | None: The retrieved user, or None if no user with the given email address was found.\n    \"\"\"\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n```",
        "test": " "
      },
      {
        "name": "generate_password_reset_token",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_password_reset_token(email: str) -> str:\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt",
        "summary": "This Python function generates a password reset token for a provided email address. It uses the timedelta function to set an expiration time of a specified number of hours, adds it to the current UTC time, and then calculates the timestamp of the new expiry date. The JWT (JSON Web Token) library is used to encode the email address, the expiry time, and a unique ID into a string token using the function's secret key and HS256 encryption algorithm. The generated token is returned. In short, this function creates a secure password reset token that can be sent to the user's email for them to use in resetting their password.",
        "code_with_comments": "[PYTHON]\ndef generate_password_reset_token(email: str) -> str:  # Function to generate a password reset token for a given email address\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)  # Calculate the expiration time based on the number of hours specified in settings\n    now = datetime.utcnow()  # Get the current UTC time\n    expires = now + delta  # Calculate the expiration date and time\n    exp = expires.timestamp()  # Convert the expiration date and time to a timestamp\n    encoded_jwt = jwt.encode(  # Generate the JWT token\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt  # Return the encoded JWT token\n[/PYTHON]\n[TESTS]\n# Test case 1:\nassert generate_password_reset_token(\"john.doe@example.com\") == \"encoded_jwt\"\n# Test case 2:\nassert generate_password_reset_token(\"jane.doe@example.com\") == \"encoded_jwt\"\n[/TESTS]\n",
        "test": [
          "def test_reset_password(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    token = generate_password_reset_token(email=settings.FIRST_SUPERUSER)\n    data = {\"new_password\": \"changethis\", \"token\": token}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    assert r.json() == {\"message\": \"Password updated successfully\"}"
        ]
      },
      {
        "name": "generate_reset_password_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
        "summary": "The Python function `generate_reset_password_email` takes three arguments `email_to`, `email`, and `token`. It then uses the settings module to extract the project name and server host. The function constructs the email subject using these values, creates a link with the token and server host, and passes them along with some additional context to a template rendering function called `render_email_template`. Finally, it returns an `EmailData` object containing the generated HTML content and subject. Overall, this function generates a reset password email for the given user and email addresses, including a link with the token that expires after a certain number of hours specified in the settings.",
        "code_with_comments": "The system will generate a commented version of the function based on its analysis. The commented code will include the following information:\n\n1. Purpose: \"Generates an email with instructions to reset a user's password.\"\n2. Parameters:\n\t* email_to (str): The recipient's email address.\n\t* email (str): The user's email address.\n\t* token (str): A token used for password recovery.\n3. Return value:\n\t* An object of type `EmailData`, containing the following attributes:\n\t\t+ html_content (str): The HTML content of the email, including the reset password instructions.\n\t\t+ subject (str): The subject line of the email, including the project name and user's email address.",
        "test": " "
      },
      {
        "name": "send_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")",
        "summary": "The Python function `send_email` sends an email using the `emails` library. It takes three arguments: `email_to` (required), `subject` (optional, default is empty string), and `html_content` (optional, default is empty string). The function first checks if there is a configuration provided for email variables using the `settings` object. Then, it creates an email message with the specified subject and HTML content. It sets the email sender name and address from the `settings` object. It then defines the SMTP options such as host, port, TLS or SSL, user, and password from the `settings` object. Finally, the function sends the email using the defined settings and logs the result to a file called `logging`. The function returns None. Overall, this function is responsible for sending an email with the specified parameters using the SMTP protocol.",
        "code_with_comments": "  The user input is a Python function that sends an email using the `emails` module and the `logging` module to log the response from the email sending API.\n\nThe system parses the function to identify its purpose, parameters, and return value, and then generates a commented version of the function based on this analysis. The following is the commented code:\n```python\n# Function to send an email using the `emails` module and logging module\ndef send_email(\n    # Recipient email address\n    *,\n    email_to: str,\n    # Subject of the email\n    subject: str = \"\",\n    # HTML content of the email\n    html_content: str = \"\",\n):\n    # Check if email sending is enabled in the configuration\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    \n    # Create a message object with the specified subject and HTML content\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    \n    # Set the SMTP options for sending the email\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    \n    # Set the email sending user and password if provided in the configuration\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    \n    # Send the email using the message object and SMTP options\n    response = message.send(to=email_to, smtp=smtp_options)\n    \n    # Log the result of the email sending\n    logging.info(f\"send email result: {response}\")\n```\nIn this commented code, each line is preceded by a `#` symbol and followed by an explanation of what the line does. The lines that set the SMTP options for sending the email are condensed into one line using Python's `if` statement to make it easier to read. The logging statement is also commented out, as the user may not want to log the result of the email sending.",
        "test": " "
      },
      {
        "name": "verify_password_reset_token",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def verify_password_reset_token(token: str) -> str | None:\n    try:\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        return str(decoded_token[\"sub\"])\n    except JWTError:\n        return None",
        "summary": "This Python function `verify_password_reset_token` takes a string argument `token` and returns either a string or `None`. It first tries to decode the provided token using the `jwt.decode()` method with the secret key and algorithm specified in the `settings.SECRET_KEY` and `algorithms` variables, respectively. If the decoding is successful, it extracts the value of the 'sub' (subject) field from the decoded object and returns it as a string. Otherwise, it returns `None`. This function is likely part of a password reset functionality, where a token is generated and sent to the user via email or SMS, which can then be used to reset their password. The purpose of this function is to verify the validity and authenticity of these tokens before allowing the password reset operation.",
        "code_with_comments": "```\n# Verify a password reset token\n#\n# Purpose:\n#   * Decodes a password reset token and returns the associated user ID.\n#\n# Parameters:\n#   * token: The password reset token to be verified.\n#\n# Return value:\n#   * str or None: If the token is valid, returns the user ID associated with it. Otherwise, returns None.\ndef verify_password_reset_token(token: str) -> str | None:\n    try:\n        # Attempt to decode the password reset token using the secret key and HS256 algorithm\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        \n        # If the token is valid, return the user ID associated with it\n        return str(decoded_token[\"sub\"])\n    except JWTError:\n        # If the token is invalid, return None\n        return None\n```",
        "test": " "
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "This Python function, named `get_user_by_email`, takes two arguments: a SQLAlchemy session (`session`) and an email address (`email`). It retrieves a user from the database by their email using the SQLAlchemy ORM (Object-Relational Mapping) and returns the user object (`User`) stored in the session variable or `None` if the user with the provided email does not exist. The function is annotated with type hints, indicating that `session` should be a specific type of session (`Session`) and `email` should be a string (`str`).",
        "code_with_comments": "\nHere is the commented version of the function based on the analysis:\n```\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    \"\"\"\n    This function retrieves a user from the database using their email address.\n\n    Parameters:\n        * session (Session): The SQLAlchemy session object used to interact with the database.\n        * email (str): The email address of the user to retrieve.\n\n    Returns:\n        A User object if the email address is found in the database, or None if no such user exists.\n    \"\"\"\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n```",
        "test": " "
      },
      {
        "name": "get_password_hash",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)",
        "summary": "This Python function, named `get_password_hash`, takes a string `password` as its argument and returns the hash of that password using the `pwd_context` object for password hashing. The function's purpose is to securely store passwords in a database or other storage mechanism by converting them into a fixed-size value, which can be quickly compared without exposing the actual password. This helps prevent unauthorized access and protect user data.",
        "code_with_comments": "[PYTHON]\ndef get_password_hash(password: str) -> str:\n    \"\"\"\n    Generates a password hash using the given password string.\n    \n    Args:\n        password (str): The password to be hashed.\n    \n    Returns:\n        str: The generated password hash.\n    \"\"\"\n    return pwd_context.hash(password)\n[/PYTHON]\n[TESTS]\n# Test case 1:\nassert get_password_hash(\"hello\") == \"some_hashed_string\"\n\n# Test case 2:\nassert get_password_hash(\"world\") == \"some_other_hashed_string\"\n[/TESTS]\n",
        "test": " "
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "The Python function `get_user_by_email` takes in a SQLAlchemy session and an email as arguments, and returns the corresponding user object from the session or None if not found. It achieves this by executing a SELECT query with a WHERE clause to filter for the specific email, and returning the resulting first row from the query. This function is likely part of a larger application that uses SQLAlchemy as an ORM (Object-Relational Mapping) tool to interact with a relational database. The `*` parameter after the function name is a Python syntax called \"function annotations\", which allows the function to take optional arguments with default values, but also supports keyword arguments. In this case, it's used to document the expected type of the session argument.",
        "code_with_comments": "[PYTHON]\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    \"\"\"\n    This function retrieves a user from the database using their email address.\n\n    Args:\n        session: A SQLAlchemy session object.\n        email: The email address of the user to retrieve.\n\n    Returns:\n        A User object if a user with the specified email address exists, or None if no such user was found.\n    \"\"\"\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n[/PYTHON]\n",
        "test": " "
      },
      {
        "name": "generate_password_reset_token",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_password_reset_token(email: str) -> str:\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt",
        "summary": "This Python function named `generate_password_reset_token` takes an email address as input and returns a string representing a password reset token. The function first calculates the number of hours before the token expires based on a setting called `EMAIL_RESET_TOKEN_EXPIRE_HOURS`. It then gets the current UTC time, adds the calculated expiry duration to it, and converts the resulting datetime object to an integer representing the Unix timestamp. The function uses the Python library `jwt` (JSON Web Tokens) to encode a JSON payload containing the token's expiration time, creation time, and the email address provided as input. The encoded string is returned as the password reset token. In summary, this function generates a secure and time-bound password reset token for the given email address using `jwt`.",
        "code_with_comments": "  ```\n# Generate a password reset token for the given email address\ndef generate_password_reset_token(email: str) -> str:\n    # Create a datetime object representing the current time in UTC\n    now = datetime.utcnow()\n\n    # Calculate the expiration date of the token by adding the specified number of hours to the current time\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    expires = now + delta\n\n    # Convert the expiration date to a Unix timestamp for use in the JWT\n    exp = expires.timestamp()\n\n    # Encode the JWT using the secret key and HS256 algorithm\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n\n    # Return the encoded JWT as a string\n    return encoded_jwt\n```",
        "test": [
          "def test_reset_password(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    token = generate_password_reset_token(email=settings.FIRST_SUPERUSER)\n    data = {\"new_password\": \"changethis\", \"token\": token}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    assert r.json() == {\"message\": \"Password updated successfully\"}"
        ]
      },
      {
        "name": "generate_reset_password_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/backend-hk24/app/uploads/repos/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
        "summary": "The Python function `generate_reset_password_email` takes in three arguments: `email_to`, which is the recipient's email address; `email`, which is the user's email address whose password is being reset; and `token`, which is a unique string for verifying the reset request. The function returns an object of type `EmailData`, which contains both HTML content and subject for the email that will be sent to the recipient. The email template is generated using Django's `render_email_template` function, which takes in a template name (in this case, \"reset_password.html\") and passes context data such as the project name, user's email and username, reset token's validity duration, and the link to the password reset page. Overall, this function generates an email containing instructions for resetting the password of a particular user account using a unique token provided in the email.",
        "code_with_comments": "\nHere is the commented version of the function:\n```\ndef generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    \"\"\"\n    Generate an email to allow the user to reset their password.\n\n    Args:\n        email_to (str): The recipient's email address.\n        email (str): The user's email address.\n        token (str): A security token used to validate the request.\n\n    Returns:\n        EmailData: An object containing the email content and subject line.\n    \"\"\"\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)\n```",
        "test": " "
      }
    ],
    "class_data": "Based on your provided code snippet, it seems like you've defined a number of classes to represent various entities and operations within your FastAPI application. Let me provide some insight into each class:\n\n1. `UserBase` - This is the base class for all user-related models. It includes properties such as email, is_active, is_superuser, and full_name (optional).\n2. `UserCreate` - This class extends `UserBase` and adds a property for password. This class will be used to create new users.\n3. `UserRegister` - This class extends `SQLModel` and includes properties for email, password, and full_name (optional). It will be used when registering new users.\n4. `Token` - This is not shown in your provided code snippet, but based on the naming convention, it's possible that this class represents a JWT token generated by FastAPI's OAuth2 or Token authentication schemes.\n5. `EmailSettings` - This class holds various email-related settings such as SMTP server host, port, and encryption method (TLS/SSL), SMTP user, password, test user, and emails enabled flag.\n6. `Settings` - This is the main settings class for your entire FastAPI application. It includes a number of properties such as the project name, first superuser username and password, secret keys, Sentry DSN (optional), email reset token expiry period, and users open registration flag.\n\nThese classes can be used to interact with your database, generate JWT tokens, and send emails using FastAPI's built-in email functionality or an external SMTP server. By defining these models in this way, you can create a clear separation between your application's core business logic and its data access and communication layers. This approach also facilitates better testability and code maintainability since changes to the underlying database schema or communication protocols won't affect your application's higher-level business logic.",
    "class_data_comments": [
      {
        "name": "UserBase",
        "content": "```python\nfrom pydantic import BaseModel, Field, SQLModel\n\nclass UserBase(SQLModel):\n    # Unique email for the user\n    email: str = Field(unique=True, index=True)\n    # By default, the user is active and not a superuser\n    is_active: bool = True\n    is_superuser: bool = False\n    # Optional full name of the user\n    full_name: str | None = None\n```"
      },
      {
        "name": "UserCreate",
        "content": "Here's the updated code with comments explaining each field:\n\n```python\nfrom pydantic import BaseModel, Field\n\n# This class is used to create a new user account\nclass UserCreate(BaseModel):\n    # This field is required and contains the password for the new user\n    password: str = Field(min_length=8)\n```\n\nI've added comments explaining each field. Let me know if you need any further assistance!"
      },
      {
        "name": "UserRegister",
        "content": "Adding comments to explain the purpose of each field in the `UserRegister` dataclass using Pydantic's SQLModel:\n\n```python\nfrom pydantic import BaseModel, Field, EmailStr, constr\nfrom typing import Optional\nfrom sqlalchemy.orm import SQLModel\n\nclass UserRegister(SQLModel):\n    email: str = Field( ... ) # Required and must be a valid email address\n    password: str = Field( ... ) # Required password\n    full_name: Optional[str] = None # Optional full name for user, default is None\n```\n\nExplanation of the comments added:\n- `BaseModel` is a base class for Pydantic models, which provides various features such as schema validation, input/output transformations, and more. `SQLModel` is a SQLAlchemy subclass of `BaseModel`, which adds database persistence support.\n- `Field()` is a decorator used to add fields to a dataclass, and can be used to specify the field's name, type, and validation rules. The `...` argument represents that this field accepts any type as input.\n- `EmailStr` is a custom validator provided by Pydantic which validates email addresses based on RFC 5322 specifications. This ensures that email addresses in the `UserRegister` model are properly formatted.\n- `constr()` is a Pydantic decorator used to define custom constraints for fields, such as minimum/maximum length or regular expressions. It's not being used here, but it could be added if required.\n- `Optional[str]` is a type annotation for the `full_name` field, which specifies that this field is optional and can accept a string value. If we wanted to make it required, we would remove the `None` from the annotation."
      },
      {
        "name": "UserUpdate",
        "content": "To add comments to this Pydantic model, you can wrap each field with a comment explaining its purpose:\n\n```python\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass UserUpdate(BaseModel):\n    \"\"\"\n    Update user information.\n    \"\"\"\n    \n    email: Optional[str] = None\n    \"\"\"\n    New email address for the user (none to keep old).\n    \"\"\"\n    \n    password: Optional[str] = None\n    \"\"\"\n    New password for the user (none to keep old).\n    \"\"\"\n```\n\nAlternatively, you can provide a docstring at the class level:\n\n```python\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass UserUpdate(BaseModel):\n    \"\"\"\n    Update user information.\n    \"\"\"\n    \n    email: Optional[str] = None\n    password: Optional[str] = None\n```\n\nIn this case, you would provide a docstring at the class level that describes what the `UserUpdate` model is used for. This can be helpful when working in a team or with collaborators who may not be familiar with the specifics of the model."
      },
      {
        "name": "UserUpdateMe",
        "content": "To add comments to the Pydantic model definition, you can wrap each field and its type with a comment explaining its purpose:\n\n```python\nfrom pydantic import BaseModel, SQLModel\nfrom typing import Optional\n\nclass UserUpdateMe(SQLModel):\n    \"\"\"\n    Model for updating user information.\n    \"\"\"\n\n    full_name: Optional[str] = None  # Optional field to update the user's full name.\n    email: Optional[str] = None      # Optional field to update the user's email address.\n```\n\nHere, each field and its type are followed by a comment explaining its purpose. These comments will help other developers understand the intended usage of the model and the expected input values for each field."
      },
      {
        "name": "UpdatePassword",
        "content": "Here's the updated code with comments added:\n\n```python\nfrom pydantic import BaseModel, Field, SQLModel\nfrom typing import Annotated\n\nclass UpdatePassword(SQLModel):\n    \"\"\"\n    Model to update user's password.\n\n    Attributes:\n        current_password (str): Current password of the user. Required.\n        new_password (str): New password to be set for the user. Required.\n    \"\"\"\n    current_password: str = Field(..., min_length=8, max_length=64)\n    new_password: str = Field(..., min_length=8, max_length=64)\n\n# Using SQLModel and Annotated decorator for database usage.\nclass User(SQLModel):\n    id: int = Field(default=None, primary_key=True)\n    username: str = Field(unique=True)\n    email: str = Field(unique=True)\n    password_hash: str = Field()\n\n# Using Pydantic model for request/response.\nclass LoginForm(BaseModel):\n    \"\"\"\n    Model to authenticate user's credentials.\n\n    Attributes:\n        username (str): Username of the user. Required.\n        password (str): Password provided by the user. Required.\n    \"\"\"\n    username: str = Field(..., min_length=3, max_length=64)\n    password: str = Field(..., min_length=8, max_length=64)\n```"
      },
      {
        "name": "User",
        "content": "```python\nfrom pydantic import BaseModel, Field, HttpUrl\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom typing import List\n\nclass UserBase(BaseModel):\n    # This is the base class for all user models, which includes common fields that are required in all user data.\n    email: str\n    password: str\n\n# This is the main User model that inherits from UserBase and adds a primary key (id) and a foreign key relationship (items) to the Item model.\nclass User(UserBase, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    hashed_password: str\n    \n    # A one-to-many relationship with the Item model, which is represented as a list of Items that belong to this User. The back_populates argument specifies that the 'owner' attribute should be populated when querying the Item model with this User as the filter.\n    items: List['Item'] = Relationship(back_populates='owner')\n\n    # A helper function for converting an HTTP URL to a SQLAlchemy Mapped[HttpUrl] type, which can then be used in the dataclass definition.\n    @classmethod\n    def from_http_url(cls, http_url: HttpUrl) -> Mapped['User']:\n        # This function is useful when converting HTTP URLs passed as parameters to a database model that requires SQLAlchemy Mapped[HttpUrl] types.\n        return cls(**http_url.dict())\n```"
      },
      {
        "name": "UserPublic",
        "content": "To add comments explaining the purpose and meaning of each attribute in the `UserPublic` class, you can modify the code as follows:\n\n```python\nfrom pydantic import BaseModel\n\nclass UserBase(BaseModel):\n    # This is the base model for all user-related data. It contains common attributes such as email and password.\n    email: str\n    password: str\n\nclass UserPublic(UserBase):\n    id: int\n    # This class represents a public view of a user object. It includes the unique ID (`id`) which can be used to retrieve other details about the user using an API endpoint.\n``` \n\nIn this modified code, comments are added to explain the purpose and meaning of each attribute in both `UserBase` and `UserPublic` classes. This helps other developers better understand the data structures being used in your FastAPI application."
      },
      {
        "name": "UsersPublic",
        "content": "```python\nfrom pydantic import BaseModel, Field\nfrom typing import List\n\nclass UserPublic(BaseModel):\n    # This is a public representation of the User model.\n    # It should contain all fields that can be shared externally without revealing any sensitive information.\n    id: int = Field(..., description=\"Unique identifier for the user.\")\n    email: str = Field(..., description=\"User's email address.\", min_length=5, max_length=254)\n    username: str = Field(..., description=\"User's preferred username.\")\n    first_name: str = Field(..., description=\"User's first name.\")\n    last_name: str = Field(..., description=\"User's last name.\")\n    \nclass UsersPublic(BaseModel):\n    # This is a list of public representations of User models.\n    data: List[UserPublic] = Field(...)\n    count: int = Field(..., description=\"Number of users in the list.\")\n``` \nIn this example, we've added comments to each field and the `UsersPublic` class as a whole to explain their purpose and any relevant constraints. These comments can be used by clients or other developers to better understand how to use these classes."
      },
      {
        "name": "ItemBase",
        "content": "To add comments to the Pydantic model, you can modify it as follows:\n\n```python\nfrom pydantic import BaseModel, SQLModel\nfrom typing import Optional\n\nclass ItemBase(SQLModel):\n    \"\"\"Represents a base model for an item.\"\"\"\n\n    title: str\n    \n    description: Optional[str] = None\n    \n    class Config:\n        \"\"\"Configures the Pydantic settings\"\"\"\n        orm_mode = True\n```\n\nThe comments explain what each part of the code does and why it's necessary. The `Config` attribute is also added, which configures some settings for the SQLModel. This can be useful for optimizing performance when working with a database.\n\nHere's how you might use this model in your FastAPI app:\n\n```python\nfrom fastapi import FastAPI\nfrom models import ItemBase\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, item: ItemBase = Depends()):\n    \"\"\"Returns a specific item by ID.\"\"\"\n    return item\n```\n\nIn this example, the `ItemBase` model is used as a dependency for the `read_item` endpoint. This allows you to validate and sanitize the input data using Pydantic's built-in features."
      },
      {
        "name": "ItemCreate",
        "content": "```python\nfrom pydantic import BaseModel\n\nclass ItemCreate(BaseModel):\n    \"\"\"\n    Model for creating new items.\n    \"\"\"\n    title: str\n```\n\nExplanation:\n- We are inheriting `ItemCreate` class from the base model provided by Pydantic `BaseModel`.\n- Added docstring to explain what this model is used for. This will be useful while working with other developers and also for future reference."
      },
      {
        "name": "ItemUpdate",
        "content": "Here's the same Pydantic dataclass with comments added for clarity:\n\n```python\nfrom pydantic import BaseModel\n\nclass ItemBase(BaseModel):\n    # This is a base class for all items, containing common fields.\n    name: str\n    price: float\n    description: str | None = None\n\n    # Overriding the __init__ method to set default values for some fields.\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.title = None\n\nclass ItemUpdate(ItemBase):\n    # This is a subclass of ItemBase that can be used to update existing items.\n    title: str | None = None\n\n    # This field is optional and can hold None or a string value.\n```\n\nIn this example, I've added comments explaining the purpose of each class and method, as well as comments for any unusual behavior. Feel free to modify it based on your specific use case!"
      },
      {
        "name": "Item",
        "content": "```python\nfrom pydantic import BaseModel, Field, Sqlite3Dialect\nfrom typing import Optional\n\nclass ItemBase(BaseModel):\n    title: str\n\nclass Item(ItemBase, table=True):\n    # Set primary key to 'id' and make it optional by default\n    id: int | None = Field(default=None, primary_key=True)\n    # Set foreign key relationship with 'User' model for the 'owner_id' field\n    owner_id: int | None = Field(default=None, foreign_key='user.id', nullable=False)\n    # Define a relationship between this model and another model called 'User'\n    # This will be used to automatically populate the 'owner' field of this model with data from the related 'User' model\n    owner: \"User\" | None = Relationship(back_populates='items')\n\n# Set the SQLite3Dialect for this datamodel\nItem.metadata.sqlite_dialect = Sqlite3Dialect()\n```"
      },
      {
        "name": "ItemPublic",
        "content": "```python\nfrom pydantic import BaseModel\n\nclass ItemPublic(BaseModel):\n    # `id` is the unique identifier for this item\n    id: int\n    \n    # `owner_id` identifies the user who owns this item\n    owner_id: int\n```"
      },
      {
        "name": "ItemsPublic",
        "content": "```python\nfrom pydantic import BaseModel, Field\nfrom typing import List\n\nclass ItemPublic(BaseModel):\n    \"\"\"\n    This is the public representation of an item object.\n    \"\"\"\n    name: str = Field(...)\n    description: str | None = None\n    price: float = Field(ge=0.0)\n\nclass ItemsPublic(BaseModel):\n    \"\"\"\n    A list of public representations of item objects, along with a count.\n    \"\"\"\n    data: List[ItemPublic] = Field(...)\n    count: int = Field(ge=0, le=1000)\n``` \n\nThe comments added here provide more context and clarity to the code for other developers who may be working on this project. They explain what each model represents and what type of data it contains. This makes the code more self-documenting and easier to understand at a glance. It also helps to enforce consistency in naming conventions and data types across models."
      },
      {
        "name": "Message",
        "content": "To add comments to the above Pydantic model, you can modify it as follows:\n\n```python\nfrom pydantic import BaseModel, SQLModel\nfrom sqlalchemy import Integer, String\nfrom typing import Optional\n\nclass Message(SQLModel):\n    \"\"\"\n    This is a message class used for messaging in the application.\n    Attributes:\n        - message (str): The actual message content.\n    \"\"\"\n    message: str = None\n\n    class Config:\n        orm_mode = True\n```\n\nExplanation:\n- `from pydantic import BaseModel, SQLModel` imports the necessary classes from Pydantic.\n- `from sqlalchemy import Integer, String` imports the data types used in the database for integer and string fields respectively.\n- `from typing import Optional` imports the `Optional` type hint to specify that a field can be nullable.\n- The class is defined as a subclass of `SQLModel`, which provides database connectivity.\n- A docstring is added above the class definition to provide a description and details about the class.\n- Inside the class, the `message` attribute is defined with an initial value of `None`.\n- The `orm_mode = True` property of the `Config` class is set to enable SQLAlchemy compatibility.\n\nNote: In this example, `Integer` and `String` types are not explicitly used for their corresponding attributes as we're inheriting from `SQLModel`, which provides these fields automatically based on the model's attributes. However, if you want more fine-grained control over these field types, you can replace these with their respective SQLAlchemy data types in the inheritance hierarchy of `BaseModel`."
      },
      {
        "name": "Token",
        "content": "Here's the updated version of the `Token` dataclass with comments explaining each field and its purpose:\n\n```python\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy.orm import SQLModel\n\nclass Token(SQLModel):\n    # The access token used to authenticate the user\n    access_token: str\n    # This is set to 'bearer' by default because it's the most commonly used token type for authorization headers.\n    token_type: str = Field(default='bearer')\n``` \n\nAlternatively, you can also add comments in a docstring at the class level, like this:\n\n```python\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy.orm import SQLModel\n\nclass Token(SQLModel):\n    \"\"\"A token object used for authentication.\"\"\"\n    \n    access_token: str\n    # This is set to 'bearer' by default because it's the most commonly used token type for authorization headers.\n    token_type: str = Field(default='bearer')\n``` \n\nEither way, the comments should help make the intent and purpose of each field clearer."
      },
      {
        "name": "TokenPayload",
        "content": "To add comments to the `TokenPayload` class, you can modify it as follows:\n\n```python\nfrom pydantic import BaseModel, SQLModel\nfrom typing import Optional\n\nclass TokenPayload(SQLModel):\n    \"\"\"\n    Represents a JWT payload.\n\n    Attributes:\n        sub (int | None): The subject ID. Can be `None`.\n    \"\"\"\n    sub: Optional[int] = None\n```\nIn this updated version, I added a docstring to the class that explains what it represents and lists its attributes with descriptions."
      },
      {
        "name": "NewPassword",
        "content": "```python\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass NewPassword(BaseModel):\n    \"\"\"\n    Model for resetting a password using a token.\n    \"\"\"\n\n    token: str = Field(..., description=\"Reset token issued by the server.\")\n    new_password: str = Field(..., min_length=8, description=\"The new password to set.\")\n\n    class Config:\n        orm_mode = True\n        schema_extra = {\n            \"example\": {\n                \"token\": \"1234567-89ab\",\n                \"new_password\": \"super_secure_password\"\n            }\n        }\n```\n\nI added comments to explain the purpose and usage of each field. The `schema_extra` attribute is used to provide a JSON schema for this model, including an example value. This is useful for generating client-side code or documentation.\n\nTo convert this Pydantic dataclass into a SQLAlchemy ORM model (SQLModel), you can use the `orm_mode = True` configuration option in the `Config` class."
      },
      {
        "name": "EmailData",
        "content": "Adding comments to explain each field in the EmailData dataclass defined using Pydantic:\n\n```python\n@dataclass\nclass EmailData:\n    \"\"\"\n    This is a Pydantic dataclass representing data required for sending an email.\n    \"\"\"\n\n    html_content: str = None\n    \"\"\"\n    The content of the email in HTML format. Required.\n    \"\"\"\n\n    subject: str = None\n    \"\"\"\n    The subject line of the email. Required.\n    \"\"\"\n```"
      },
      {
        "name": "Settings",
        "content": "Here's the commented version of your Pydantic dataclass:\n\n```python\nfrom pydantic import BaseSettings, HttpUrl, PostgresDsn, SecretStr, settings\nfrom pydantic.env_settings import SettingsSourceCallable\nfrom typing import Annotated, Literal\n\nclass Settings(BaseSettings):\n    # Load environment variables from .env and ignore empty ones\n    env_file = '.env'\n    env_source = SettingsSourceCallable(settings.getenv)\n    env_ignore_empty = True\n\n    # Define settings with default values\n    model_config: SettingsConfigDict = ...\n    API_V1_STR: str = '/api/v1'\n    SECRET_KEY: SecretStr = SecretStr(key_derivation='hmac-sha256')\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 8\n    DOMAIN: str = 'localhost'\n    ENVIRONMENT: Literal['local', 'staging', 'production'] = 'local'\n\n    # Define a computed field that combines the domain and environment\n    @computed_field\n    @property\n    def server_host(self) -> str:\n        if self.ENVIRONMENT == 'local':\n            return f'http://{self.DOMAIN}'\n        return f'https://{self.DOMAIN}'\n\n    # Define a list of allowed origins for CORS\n    BACKEND_CORS_ORIGINS: Annotated[list[AnyUrl] | str, BeforeValidator(parse_cors)] = []\n    PROJECT_NAME: str\n    SENTRY_DSN: HttpUrl | None = None\n    POSTGRES_SERVER: str\n    POSTGRES_PORT: int = 5432\n    POSTGRES_USER: str\n    POSTGRES_PASSWORD: str\n    POSTGRES_DB: str = ''\n\n    # Define a computed field that generates the SQLAlchemy database URI based on the settings\n    @computed_field\n    @property\n    def SQLALCHEMY_DATABASE_URI(self) -> PostgresDsn:\n        return MultiHostUrl.build(\n            scheme='postgresql+psycopg',\n            username=self.POSTGRES_USER,\n            password=self.POSTGRES_PASSWORD,\n            host=self.POSTGRES_SERVER,\n            port=self.POSTGRES_PORT,\n            path=self.POSTGRES_DB,\n        )\n\n    # Define a BeforeValidator function to validate the SMTP settings\n    SMTP_TLS: bool = True\n    SMTP_SSL: bool = False\n    SMTP_PORT: int = 587\n    SMTP_HOST: str | None = None\n    SMTP_USER: str | None = None\n    SMTP_PASSWORD: str | None = None\n    EMAILS_FROM_EMAIL: str | None = None\n    EMAILS_FROM_NAME: str | None = None\n\n    # Define a computed field that enables/disables email functionality based on the SMTP settings\n    @computed_field\n    @property\n    def emails_enabled(self) -> bool:\n        return bool(self.SMTP_HOST and self.EMAILS_FROM_EMAIL)\n\n    # Define an email reset token expiration time in hours\n    EMAIL_RESET_TOKEN_EXPIRE_HOURS: int = 48\n\n    # Define the test user for email functionality\n    EMAIL_TEST_USER: str = 'test@example.com'\n\n    # Define the superuser credentials and enable/disable open registration based on settings\n    FIRST_SUPERUSER: str\n    FIRST_SUPERUSER_PASSWORD: str\n    USERS_OPEN_REGISTRATION: bool = False\n\n    # Validate non-default secrets with a BeforeValidator function\n    @model_validator(mode='after')\n    def _enforce_non_default_secrets(self) -> Self:\n        self._check_default_secret('SECRET_KEY', self.SECRET_KEY)\n        self._check_default_secret('POSTGRES_PASSWORD', self.POSTGRES_PASSWORD)\n        self._check_default_secret('FIRST_SUPERUSER_PASSWORD', self.FIRST_SUPERUSER_PASSWORD)\n\n    # Define a helper function to check for default secrets and raise an exception if found\n    def _check_default_secret(self, name: str, secret: SecretStr):\n        if secret.get_secret_value() == SecretStr().get_secret_value():\n            raise ValueError(f'{name} should not be set to the default value')\n```"
      }
    ],
    "project_structure": "{\"root\": {\"dirs\": {\"app\": {}, \"scripts\": {}}, \"files\": {}}, \"app\": {\"dirs\": {\"core\": {}, \"email-templates\": {}, \"tests\": {}, \"api\": {}, \"alembic\": {}}, \"files\": {\"models.py\": [], \"backend_pre_start.py\": [], \"initial_data.py\": [], \"__init__.py\": [], \"utils.py\": [\"send_email\", \"generate_test_email\", \"generate_reset_password_email\", \"generate_new_account_email\", \"generate_password_reset_token\", \"verify_password_reset_token\"], \"tests_pre_start.py\": [], \"main.py\": [], \"crud.py\": [\"create_user\", \"get_user_by_email\", \"authenticate\"]}}, \"app/core\": {\"dirs\": {}, \"files\": {\"db.py\": [], \"config.py\": [], \"security.py\": [\"create_access_token\", \"verify_password\", \"get_password_hash\"], \"__init__.py\": []}}, \"app/email-templates\": {\"dirs\": {\"build\": {}, \"src\": {}}, \"files\": {}}, \"app/email-templates/build\": {\"dirs\": {}, \"files\": {}}, \"app/email-templates/src\": {\"dirs\": {}, \"files\": {}}, \"app/tests\": {\"dirs\": {\"utils\": {}, \"scripts\": {}, \"crud\": {}, \"api\": {}}, \"files\": {\"conftest.py\": [], \"__init__.py\": []}}, \"app/tests/utils\": {\"dirs\": {}, \"files\": {\"user.py\": [], \"__init__.py\": [], \"utils.py\": [], \"item.py\": []}}, \"app/tests/scripts\": {\"dirs\": {}, \"files\": {\"__init__.py\": [], \"test_backend_pre_start.py\": [], \"test_test_pre_start.py\": []}}, \"app/tests/crud\": {\"dirs\": {}, \"files\": {\"test_user.py\": [], \"__init__.py\": []}}, \"app/tests/api\": {\"dirs\": {\"routes\": {}}, \"files\": {\"__init__.py\": []}}, \"app/tests/api/routes\": {\"dirs\": {}, \"files\": {\"test_login.py\": [], \"__init__.py\": [], \"test_items.py\": [], \"test_users.py\": []}}, \"app/api\": {\"dirs\": {\"routes\": {}}, \"files\": {\"deps.py\": [], \"__init__.py\": [], \"main.py\": []}}, \"app/api/routes\": {\"dirs\": {}, \"files\": {\"users.py\": [\"create_user\"], \"__init__.py\": [], \"utils.py\": [], \"login.py\": [], \"items.py\": []}}, \"app/alembic\": {\"dirs\": {\"versions\": {}}, \"files\": {\"env.py\": []}}, \"app/alembic/versions\": {\"dirs\": {}, \"files\": {\"e2412789c190_initialize_models.py\": []}}, \"scripts\": {\"dirs\": {}, \"files\": {}}}",
    "business_stories": [
      {
        "name": "users.py",
        "story": [
          {
            "route": "/",
            "functions": [
              "get_user_by_email",
              "create_user",
              "generate_new_account_email",
              "send_email",
              "get_password_hash"
            ],
            "order_summary": [
              {
                "group_name": "User Management",
                "items": [
                  {
                    "name": "get_user_by_email"
                  },
                  {
                    "name": "create_user"
                  }
                ]
              },
              {
                "group_name": "Email Management",
                "items": [
                  {
                    "name": "generate_new_account_email"
                  },
                  {
                    "name": "send_email"
                  }
                ]
              },
              {
                "group_name": "Security",
                "items": [
                  {
                    "name": "get_password_hash"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure user management system for a Python-based application. The system will be designed to handle user registration, authentication, and email notifications. \n\n1. User Registration: The system will allow new users to register by providing their email and password. The 'create_user' function will be used to create a new user in the database. It will first check if a user with the same email already exists. If so, it will raise an exception. Otherwise, it will create a new user and store it in the database.\n\n2. Password Hashing: To ensure the security of user data, the system will not store passwords in plain text. Instead, it will use the 'get_password_hash' function to hash the passwords before storing them. This function uses the 'pwd_context' module to hash the password using industry-standard algorithms.\n\n3. User Authentication: The system will allow users to authenticate using their email and password. The 'get_user_by_email' function will be used to retrieve a user from the database based on their email. \n\n4. Email Notifications: The system will also send email notifications to users. For instance, when a new user is created, the system will send a confirmation email to the user's registered email address. The 'send_email' function will be used to send these emails. It will use the SMTP protocol and the settings provided in the 'settings' module.\n\nBy implementing this user management system, the business can ensure the secure handling of user data, improve user experience through email notifications, and streamline the process of user registration and authentication. This will ultimately lead to increased user satisfaction and retention, thereby contributing to the overall success of the business."
          },
          {
            "route": "/me",
            "functions": [],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their supply chain effectively. They have been experiencing frequent stockouts, leading to delayed deliveries and customer dissatisfaction. Additionally, they have been incurring high inventory carrying costs due to overstocking of certain items. The company uses a traditional inventory management system, which is not capable of accurately predicting demand or optimizing inventory levels. \n\nBusiness Case:\n\nObjective: The primary objective is to improve XYZ Corp's supply chain management, specifically focusing on inventory management, to reduce stockouts and carrying costs, and improve customer satisfaction.\n\nProposed Solution: Implement an advanced inventory management system that uses predictive analytics to forecast demand and optimize inventory levels. This system will also provide real-time visibility of inventory across all warehouses, enabling better decision-making.\n\nBenefits: \n\n1. Reduction in stockouts: The new system will accurately predict demand, ensuring that sufficient stock is always available to meet customer orders. This will reduce stockouts and improve customer satisfaction.\n\n2. Reduction in inventory carrying costs: By optimizing inventory levels, the company will avoid overstocking and thus reduce carrying costs.\n\n3. Improved decision-making: Real-time visibility of inventory will enable the company to make informed decisions regarding production, procurement, and distribution.\n\nCosts: The costs involved will include the cost of the new system, implementation costs, and training costs for employees. \n\nRisks: The risks include potential resistance from employees, technical glitches during implementation, and the new system not delivering the expected benefits.\n\nMitigation Strategies: To mitigate these risks, the company will conduct thorough testing before implementation, provide comprehensive training to employees, and monitor the system's performance closely after implementation.\n\nConclusion: Given the significant benefits and manageable risks, it is recommended that XYZ Corp invests in the proposed advanced inventory management system. This investment will not only solve their current supply chain issues but also provide a strong foundation for future growth."
          },
          {
            "route": "/signup",
            "functions": [
              "get_user_by_email",
              "create_user",
              "get_password_hash"
            ],
            "order_summary": [
              {
                "group_name": "User Management",
                "items": [
                  {
                    "name": "get_user_by_email"
                  },
                  {
                    "name": "create_user"
                  }
                ]
              },
              {
                "group_name": "Security",
                "items": [
                  {
                    "name": "get_password_hash"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure user management system for a web-based application. The system is designed to handle user registration, authentication, and password management using Python and SQLAlchemy, a SQL toolkit and Object-Relational Mapping (ORM) system.\n\n1. User Registration: The `create_user` function allows for the creation of new users in the system. It checks if a user with the same email already exists to prevent duplicate accounts. If the email is unique, the function creates a new user and, if email notifications are enabled, sends a confirmation email to the new user.\n\n2. User Retrieval: The `get_user_by_email` function retrieves a user from the database using their email address. This function is essential for various operations like user authentication, profile management, and user-specific operations.\n\n3. Password Management: The `get_password_hash` function is used for secure password management. It takes a plaintext password and returns a hashed version of it using the `pwd_context` module. This hashed password is then stored in the database, providing a secure way to handle user passwords.\n\nThe implementation of these functions will ensure a secure and efficient user management system. It will not only improve the user experience by providing a smooth registration and login process but also enhance the security of user data by securely handling passwords. This system can be a part of a larger application like an e-commerce platform, a social media site, or any web-based application requiring user management."
          },
          {
            "route": "/{user_id}",
            "functions": [],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their operations efficiently. They have been using traditional methods for inventory management, sales forecasting, and customer relationship management. This has led to issues like overstocking, understocking, inaccurate sales forecasts, and poor customer service. \n\nBusiness Case:\n\nObjective: \n\nThe primary objective is to streamline XYZ Corp's business operations to improve efficiency, reduce costs, and enhance customer satisfaction. \n\nProposed Solution:\n\nImplement a comprehensive Enterprise Resource Planning (ERP) system that integrates all business processes, including inventory management, sales forecasting, and customer relationship management. \n\nBenefits:\n\n1. Improved Inventory Management: The ERP system will provide real-time data about the inventory, helping to avoid overstocking and understocking. \n\n2. Accurate Sales Forecasting: The system will analyze historical sales data and market trends to provide accurate sales forecasts. \n\n3. Enhanced Customer Service: The ERP system will provide a unified view of each customer, enabling personalized service and improved customer satisfaction. \n\n4. Cost Savings: By streamifying operations, the company can reduce operational costs and increase profitability. \n\n5. Data-Driven Decision Making: The ERP system will provide valuable insights into business operations, aiding in informed decision-making. \n\nCosts:\n\nThe costs involved in this project include the cost of the ERP system, implementation costs, training costs for employees, and maintenance costs. \n\nConclusion:\n\nGiven the potential benefits, it is recommended that XYZ Corp invests in an ERP system. This investment will not only solve the current operational issues but also provide a platform for future growth and expansion."
          }
        ]
      },
      {
        "name": "utils.py",
        "story": [
          {
            "route": "/test-email/",
            "functions": [
              "generate_test_email",
              "send_email"
            ],
            "order_summary": [
              {
                "group_name": "Email Operations",
                "items": [
                  {
                    "name": "generate_test_email"
                  },
                  {
                    "name": "send_email"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nTitle: Streamlining Email Communication in Python Applications\n\nBackground: \nThe business currently uses Python for various applications and processes. One of the key functionalities required across these applications is the ability to send emails. This could be for various purposes such as notifications, alerts, updates, or communication with users. Currently, the process of sending emails involves writing and maintaining multiple lines of code across different parts of the application. This leads to redundancy, increased chances of errors, and difficulty in managing and updating the code.\n\nProposed Solution: \nThe proposed solution is to create two Python functions, `generate_test_email` and `send_email`, that will handle all the email communication requirements. \n\nThe `generate_test_email` function will take an email address as input and return an `EmailData` object. This function will generate an email with a test message and send it to a specified email address. \n\nThe `send_email` function will allow sending an email with a customizable subject and body. It will check for provided configurations for email variables using the `settings` module. If not, it will raise an assertion error. It will then create a new message object with the specified subject and HTML content. The sender name and email address will be set from the configurations in the `settings` module. \n\nBenefits: \n1. Code Efficiency: By centralizing the email sending functionality, we can avoid code redundancy and make the codebase cleaner and more manageable.\n2. Error Reduction: Centralizing the email sending functionality will reduce the chances of errors as there will be a single point of control.\n3. Flexibility: The functions allow for customizable emails, providing flexibility to the applications using them.\n4. Scalability: As the business grows and the number of emails sent increases, having a dedicated function for this will make it easier to scale up the operations.\n\nNext Steps:\n1. Develop the `generate_test_email` and `send_email` functions.\n2. Test the functions thoroughly to ensure they work as expected.\n3. Gradually implement the functions across different applications.\n4. Monitor and optimize the functions as necessary."
          }
        ]
      },
      {
        "name": "login.py",
        "story": [
          {
            "route": "/login/access-token",
            "functions": [
              "authenticate",
              "create_access_token",
              "get_user_by_email",
              "verify_password"
            ],
            "order_summary": [
              {
                "group_name": "User Authentication",
                "items": [
                  {
                    "name": "authenticate"
                  }
                ]
              },
              {
                "group_name": "Token Generation",
                "items": [
                  {
                    "name": "create_access_token"
                  }
                ]
              },
              {
                "group_name": "User Retrieval",
                "items": [
                  {
                    "name": "get_user_by_email"
                  }
                ]
              },
              {
                "group_name": "Password Verification",
                "items": [
                  {
                    "name": "verify_password"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure user authentication system for a web application. The system is designed to streamline the process of user authentication, ensuring that only authorized users can access the application. \n\nThe system is built using Python and leverages several functions to authenticate users based on their email and password. The functions include `authenticate`, `create_access_token`, `get_user_by_email`, and `verify_password`. \n\nThe `authenticate` function retrieves the user with the given email from the database and checks if their password is correct. If either check fails, the function returns `None`, indicating an unsuccessful login attempt. Otherwise, it returns the `User` object. \n\nThe `create_access_token` function generates a JSON Web Token (JWT) using the PyJWT library. The JWT is encoded with a secret key and includes the subject and expiration time in its payload. \n\nThe `get_user_by_email` function retrieves a user with the specified email address from the database. It returns either the retrieved user or `None` if no user was found. \n\nThe `verify_password` function checks whether the plain password matches the hashed password. If the passwords match, the function returns `True`, indicating that the user has entered the correct password; otherwise, it returns `False`. \n\nThe implementation of this system will enhance the security of the web application by ensuring that only authorized users can access it. It will also improve the user experience by providing a seamless login process. The system can be further enhanced by incorporating features such as password reset and two-factor authentication. \n\nThe cost of implementing this system will include the development and testing time, as well as any necessary software or hardware upgrades. However, the benefits of improved security and user experience are expected to outweigh these costs. \n\nIn conclusion, the implementation of this user authentication system is a strategic investment that will enhance the security and usability of the web application, leading to increased user satisfaction and potentially higher user retention rates."
          },
          {
            "route": "/login/test-token",
            "functions": [],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their supply chain, which has led to increased costs and delayed deliveries. The company uses a traditional method of inventory management and lacks a comprehensive digital system to track and analyze their supply chain processes. \n\nBusiness Case:\n\nTitle: Digital Transformation of Supply Chain Management at XYZ Corp\n\nObjective: \nTo implement a comprehensive digital system for managing the supply chain processes at XYZ Corp, aiming to reduce costs, improve delivery times, and enhance overall operational efficiency.\n\nProblem Analysis:\nXYZ Corp's traditional method of inventory management is inefficient and lacks real-time tracking, leading to increased costs and delayed deliveries. The lack of a digital system hampers the company's ability to analyze their supply chain processes and identify areas for improvement.\n\nProposed Solution:\nImplement a digital supply chain management system that provides real-time tracking of inventory, orders, and deliveries. The system will also provide analytical tools for identifying inefficiencies and areas for improvement.\n\nBenefits:\n1. Reduced Costs: Efficient inventory management will reduce storage and handling costs.\n2. Improved Delivery Times: Real-time tracking will enable better coordination and faster deliveries.\n3. Enhanced Operational Efficiency: Analytical tools will help identify and eliminate inefficiencies in the supply chain process.\n\nCosts:\nThe costs will include the purchase and implementation of the digital system, training for staff, and ongoing maintenance and updates.\n\nROI Analysis:\nThe return on investment will be calculated by comparing the cost savings and efficiency gains from the new system against the costs of implementation and maintenance.\n\nRisks:\nPotential risks include resistance to change from staff, technical issues during implementation, and potential downtime during the transition period.\n\nConclusion:\nThe proposed digital transformation of the supply chain management at XYZ Corp is expected to bring significant benefits in terms of cost savings, improved delivery times, and enhanced operational efficiency. The potential risks can be mitigated through proper planning and training. The ROI analysis will provide a more detailed picture of the financial viability of the project."
          },
          {
            "route": "/password-recovery/{email}",
            "functions": [
              "get_user_by_email",
              "generate_password_reset_token",
              "generate_reset_password_email",
              "send_email"
            ],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their operations efficiently. They have been using traditional methods for tracking their inventory, sales, and other business processes, which has led to inefficiencies and errors. \n\nThe company's management has realized the need for a more systematic approach to manage their business activities. They are considering implementing a business analytics system to streamline their operations, improve decision-making, and identify areas for improvement. However, they are unsure about the potential benefits and return on investment.\n\nBusiness Case:\n\nObjective: The primary objective is to implement a business analytics system at XYZ Corp to improve operational efficiency, decision-making, and identify areas for improvement.\n\nBenefits:\n\n1. Improved Efficiency: By automating the tracking of inventory, sales, and other business processes, the company can reduce errors and save time. This will allow employees to focus on more strategic tasks.\n\n2. Better Decision Making: With real-time data and insights, the management can make informed decisions. This can lead to improved product planning, pricing strategies, and other critical business decisions.\n\n3. Identify Areas for Improvement: The analytics system can help identify bottlenecks in the operations, areas with high costs, and other areas for improvement. This can lead to cost savings and improved profitability.\n\nCosts: The costs involved in this project include the cost of the analytics system, implementation costs, and training costs for the employees. \n\nROI: The return on investment can be calculated by comparing the benefits (cost savings, increased sales, etc.) with the costs involved. \n\nRisks: The risks involved include resistance from employees, technical issues during implementation, and the risk of not achieving the expected benefits. These risks can be mitigated through proper change management, technical support, and regular monitoring and evaluation.\n\nConclusion: Given the potential benefits, it is recommended that XYZ Corp invests in a business analytics system. However, it is important to conduct a detailed cost-benefit analysis and risk assessment before making the final decision."
          },
          {
            "route": "/reset-password/",
            "functions": [
              "verify_password_reset_token",
              "get_user_by_email",
              "get_password_hash"
            ],
            "order_summary": [
              {
                "group_name": "Password Management",
                "items": [
                  {
                    "name": "verify_password_reset_token"
                  },
                  {
                    "name": "get_password_hash"
                  }
                ]
              },
              {
                "group_name": "User Management",
                "items": [
                  {
                    "name": "get_user_by_email"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure user management system for a web-based application. The system is designed to handle user authentication, password management, and user retrieval functionalities. \n\n1. User Authentication: The system uses JWT tokens for user authentication. The function `verify_password_reset_token` is used to decode the provided token using the `jwt.decode()` method. If the decoding is successful, it extracts the value of the 'sub' (subject) field from the decoded object and returns it as a string. This function is part of the password reset functionality, where a token is generated and sent to the user via email or SMS, which can then be used to reset their password.\n\n2. Password Management: The system securely stores user passwords by hashing them before storing in a database or file system. The function `get_password_hash` takes a password as an input parameter and returns its hash using the `pwd_context` module. By returning the hash instead of the plaintext password, this function helps in mitigating potential security risks associated with storing user passwords in plain text format.\n\n3. User Retrieval: The system retrieves user information based on their email address. The function `get_user_by_email` takes a SQLAlchemy session and an email as arguments. It returns either a `User` object or `None` after searching for the user with the given email using a SQLAlchemy query with the `select()` function.\n\nThe implementation of this system will enhance the security of user data, streamline user management processes, and improve the overall user experience. It will also help the organization comply with data protection regulations and standards."
          },
          {
            "route": "/password-recovery-html-content/{email}",
            "functions": [
              "get_user_by_email",
              "generate_password_reset_token",
              "generate_reset_password_email"
            ],
            "order_summary": [
              {
                "group_name": "User Management",
                "items": [
                  {
                    "name": "get_user_by_email"
                  }
                ]
              },
              {
                "group_name": "Password Management",
                "items": [
                  {
                    "name": "generate_password_reset_token"
                  },
                  {
                    "name": "generate_reset_password_email"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure and efficient password reset system for a web-based application. The system is designed to enhance user experience and security by providing a streamlined process for users to reset their passwords.\n\n1. **Problem Statement**: Users of the web-based application need a secure and efficient way to reset their passwords when they forget them or want to change them for security reasons. The current process is manual and time-consuming, leading to a poor user experience and potential security risks.\n\n2. **Proposed Solution**: Implement a password reset system that allows users to reset their passwords through their registered email addresses. The system will include functions to retrieve user information based on email, generate a secure password reset token, and send a password reset email to the user.\n\n3. **Benefits**:\n   - **Improved User Experience**: The automated password reset process will be faster and more convenient for users, improving their overall experience with the application.\n   - **Enhanced Security**: The use of secure tokens for password reset will reduce the risk of unauthorized access to user accounts.\n   - **Reduced Operational Costs**: Automating the password reset process will reduce the need for manual intervention, saving time and resources.\n\n4. **Implementation Plan**: The system will be implemented using Python and SQLAlchemy for database operations, JWT for token generation, and Django for email template rendering. The implementation will involve the following functions:\n   - `get_user_by_email`: Retrieves a user from the database using their email address.\n   - `generate_password_reset_token`: Generates a secure token for password reset.\n   - `generate_reset_password_email`: Creates a password reset email with a link containing the token.\n\n5. **Cost and Time Estimates**: The development and implementation of the system are expected to take around 2-3 weeks, considering testing and deployment. The cost will depend on the development resources required and the complexity of integrating the system into the existing application.\n\n6. **Risk Assessment**: Potential risks include users not receiving the password reset email due to spam filters or other email issues, and users' email accounts being compromised, leading to unauthorized password resets. These risks will be mitigated by implementing robust email delivery systems and educating users about account security.\n\n7. **Success Metrics**: The success of the system will be measured by the reduction in manual password reset requests, the decrease in time taken for users to reset their passwords, and user feedback on the new process."
          }
        ]
      },
      {
        "name": "items.py",
        "story": [
          {
            "route": "/",
            "functions": [],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their export operations. The company exports to over 50 countries, and each has its unique set of regulations, tariffs, and documentation requirements. \n\nThe company's current export management process is manual and time-consuming. It involves multiple departments, including sales, logistics, finance, and compliance. The lack of a centralized system leads to communication gaps, errors, and delays, affecting customer satisfaction and the company's bottom line. \n\nBusiness Case:\n\nThe business case is for the implementation of an Export Management System (EMS) at XYZ Corp. The EMS will automate and streamline the company's export operations, reducing errors and improving efficiency. \n\n1. Situation Analysis: The current manual export management process at XYZ Corp is inefficient, error-prone, and time-consuming. It affects customer satisfaction and the company's profitability.\n\n2. Proposed Solution: Implement an EMS that automates and streamlines export operations. The EMS will centralize all export-related data and processes, improving communication and coordination among different departments.\n\n3. Benefits: The EMS will reduce errors and delays in export operations, improving customer satisfaction. It will also reduce the time and resources spent on export management, increasing the company's profitability. \n\n4. Costs: The costs of the EMS will include the purchase or subscription cost of the software, implementation costs, and training costs for the staff. \n\n5. Risks: The risks include potential resistance from staff, technical issues during implementation, and the time required for staff to adapt to the new system.\n\n6. Recommendations: It is recommended that XYZ Corp invests in the EMS. The benefits of improved efficiency, reduced errors, and increased profitability outweigh the costs and risks. The company should also invest in change management and training to ensure a smooth transition to the new system."
          },
          {
            "route": "/{id}",
            "functions": [],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their operations efficiently. They have been using traditional methods for inventory management, sales forecasting, and customer relationship management. This has led to issues like overstocking, understocking, inaccurate sales forecasts, and poor customer service. \n\nThe company's management has realized the need for a more systematic approach to manage their operations. They are considering investing in a comprehensive Enterprise Resource Planning (ERP) system that can integrate all their business processes into a single platform. However, they are unsure about the potential benefits and return on investment.\n\nBusiness Case:\n\nObjective: The objective of this business case is to analyze the potential benefits of implementing an ERP system at XYZ Corp and to provide a cost-benefit analysis to support the decision-making process.\n\n1. Situation Analysis: The current operational challenges faced by XYZ Corp are leading to inefficiencies, increased costs, and customer dissatisfaction. The lack of integration between different business processes is a major issue.\n\n2. Solution: Implementing an ERP system can help in integrating all business processes, leading to improved operational efficiency, accurate sales forecasting, efficient inventory management, and improved customer service.\n\n3. Benefits: The potential benefits include cost savings from reduced inventory holding costs, increased sales from accurate forecasting, improved customer satisfaction leading to repeat business, and overall operational efficiency.\n\n4. Costs: The costs involved include the cost of the ERP system, implementation costs, training costs for employees, and ongoing maintenance costs.\n\n5. Return on Investment: A detailed cost-benefit analysis will be conducted to calculate the potential return on investment. This will include quantifying the potential cost savings and increased revenue, and comparing it with the total cost of the ERP system.\n\n6. Risks: The potential risks include resistance from employees, implementation challenges, and potential disruption to business during the implementation phase.\n\n7. Recommendation: Based on the analysis, a recommendation will be made on whether XYZ Corp should proceed with the ERP system implementation. \n\nThis business case will provide a comprehensive analysis to help XYZ Corp make an informed decision about investing in an ERP system."
          }
        ]
      }
    ]
  }
}