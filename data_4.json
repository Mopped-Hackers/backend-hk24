{
  "https://github.com/tiangolo/full-stack-fastapi-template": {
    "name": "full-stack-fastapi-template",
    "url": "https://github.com/tiangolo/full-stack-fastapi-template",
    "function_to_code": {
      "init": "def init(db_engine: Engine) -> None:\n    try:\n        # Try to create session to check if DB is awake\n        with Session(db_engine) as session:\n            session.exec(select(1))\n    except Exception as e:\n        logger.error(e)\n        raise e",
      "main": "def main() -> None:\n    logger.info(\"Initializing service\")\n    init(engine)\n    logger.info(\"Service finished initializing\")",
      "render_email_template": "def render_email_template(*, template_name: str, context: dict[str, Any]) -> str:\n    template_str = (\n        Path(__file__).parent / \"email-templates\" / \"build\" / template_name\n    ).read_text()\n    html_content = Template(template_str).render(context)\n    return html_content",
      "send_email": "def send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")",
      "generate_test_email": "def generate_test_email(email_to: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Test email\"\n    html_content = render_email_template(\n        template_name=\"test_email.html\",\n        context={\"project_name\": settings.PROJECT_NAME, \"email\": email_to},\n    )\n    return EmailData(html_content=html_content, subject=subject)",
      "generate_reset_password_email": "def generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
      "generate_new_account_email": "def generate_new_account_email(\n    email_to: str, username: str, password: str\n) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - New account for user {username}\"\n    html_content = render_email_template(\n        template_name=\"new_account.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": settings.server_host,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
      "generate_password_reset_token": "def generate_password_reset_token(email: str) -> str:\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt",
      "verify_password_reset_token": "def verify_password_reset_token(token: str) -> str | None:\n    try:\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        return str(decoded_token[\"sub\"])\n    except JWTError:\n        return None",
      "custom_generate_unique_id": "def custom_generate_unique_id(route: APIRoute) -> str:\n    return f\"{route.tags[0]}-{route.name}\"",
      "create_user": "def create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    return user",
      "update_user": "def update_user(\n    *,\n    session: SessionDep,\n    user_id: int,\n    user_in: UserUpdate,\n) -> Any:\n    \"\"\"\n    Update a user.\n    \"\"\"\n\n    db_user = session.get(User, user_id)\n    if not db_user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this id does not exist in the system\",\n        )\n    if user_in.email:\n        existing_user = crud.get_user_by_email(session=session, email=user_in.email)\n        if existing_user and existing_user.id != user_id:\n            raise HTTPException(\n                status_code=409, detail=\"User with this email already exists\"\n            )\n\n    db_user = crud.update_user(session=session, db_user=db_user, user_in=user_in)\n    return db_user",
      "get_user_by_email": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
      "authenticate": "def authenticate(*, session: Session, email: str, password: str) -> User | None:\n    db_user = get_user_by_email(session=session, email=email)\n    if not db_user:\n        return None\n    if not verify_password(password, db_user.hashed_password):\n        return None\n    return db_user",
      "create_item": "def create_item(\n    *, session: SessionDep, current_user: CurrentUser, item_in: ItemCreate\n) -> Any:\n    \"\"\"\n    Create new item.\n    \"\"\"\n    item = Item.model_validate(item_in, update={\"owner_id\": current_user.id})\n    session.add(item)\n    session.commit()\n    session.refresh(item)\n    return item",
      "init_db": "def init_db(session: Session) -> None:\n    # Tables should be created with Alembic migrations\n    # But if you don't want to use migrations, create\n    # the tables un-commenting the next lines\n    # from sqlmodel import SQLModel\n\n    # from app.core.engine import engine\n    # This works because the models are already imported and registered from app.models\n    # SQLModel.metadata.create_all(engine)\n\n    user = session.exec(\n        select(User).where(User.email == settings.FIRST_SUPERUSER)\n    ).first()\n    if not user:\n        user_in = UserCreate(\n            email=settings.FIRST_SUPERUSER,\n            password=settings.FIRST_SUPERUSER_PASSWORD,\n            is_superuser=True,\n        )\n        user = crud.create_user(session=session, user_create=user_in)",
      "parse_cors": "def parse_cors(v: Any) -> list[str] | str:\n    if isinstance(v, str) and not v.startswith(\"[\"):\n        return [i.strip() for i in v.split(\",\")]\n    elif isinstance(v, list | str):\n        return v\n    raise ValueError(v)",
      "server_host": "def server_host(self) -> str:\n        # Use HTTPS for anything other than local development\n        if self.ENVIRONMENT == \"local\":\n            return f\"http://{self.DOMAIN}\"\n        return f\"https://{self.DOMAIN}\"",
      "SQLALCHEMY_DATABASE_URI": "def SQLALCHEMY_DATABASE_URI(self) -> PostgresDsn:\n        return MultiHostUrl.build(\n            scheme=\"postgresql+psycopg\",\n            username=self.POSTGRES_USER,\n            password=self.POSTGRES_PASSWORD,\n            host=self.POSTGRES_SERVER,\n            port=self.POSTGRES_PORT,\n            path=self.POSTGRES_DB,\n        )",
      "_set_default_emails_from": "def _set_default_emails_from(self) -> Self:\n        if not self.EMAILS_FROM_NAME:\n            self.EMAILS_FROM_NAME = self.PROJECT_NAME\n        return self",
      "emails_enabled": "def emails_enabled(self) -> bool:\n        return bool(self.SMTP_HOST and self.EMAILS_FROM_EMAIL)",
      "_check_default_secret": "def _check_default_secret(self, var_name: str, value: str | None) -> None:\n        if value == \"changethis\":\n            message = (\n                f'The value of {var_name} is \"changethis\", '\n                \"for security, please change it, at least for deployments.\"\n            )\n            if self.ENVIRONMENT == \"local\":\n                warnings.warn(message, stacklevel=1)\n            else:\n                raise ValueError(message)",
      "_enforce_non_default_secrets": "def _enforce_non_default_secrets(self) -> Self:\n        self._check_default_secret(\"SECRET_KEY\", self.SECRET_KEY)\n        self._check_default_secret(\"POSTGRES_PASSWORD\", self.POSTGRES_PASSWORD)\n        self._check_default_secret(\n            \"FIRST_SUPERUSER_PASSWORD\", self.FIRST_SUPERUSER_PASSWORD\n        )\n\n        return self",
      "create_access_token": "def create_access_token(subject: str | Any, expires_delta: timedelta) -> str:\n    expire = datetime.utcnow() + expires_delta\n    to_encode = {\"exp\": expire, \"sub\": str(subject)}\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt",
      "verify_password": "def verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)",
      "get_password_hash": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)",
      "get_db": "def get_db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        yield session",
      "get_current_user": "def get_current_user(session: SessionDep, token: TokenDep) -> User:\n    try:\n        payload = jwt.decode(\n            token, settings.SECRET_KEY, algorithms=[security.ALGORITHM]\n        )\n        token_data = TokenPayload(**payload)\n    except (JWTError, ValidationError):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials\",\n        )\n    user = session.get(User, token_data.sub)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    if not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return user",
      "get_current_active_superuser": "def get_current_active_superuser(current_user: CurrentUser) -> User:\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=400, detail=\"The user doesn't have enough privileges\"\n        )\n    return current_user",
      "read_users": "def read_users(session: SessionDep, skip: int = 0, limit: int = 100) -> Any:\n    \"\"\"\n    Retrieve users.\n    \"\"\"\n\n    count_statement = select(func.count()).select_from(User)\n    count = session.exec(count_statement).one()\n\n    statement = select(User).offset(skip).limit(limit)\n    users = session.exec(statement).all()\n\n    return UsersPublic(data=users, count=count)",
      "update_user_me": "def update_user_me(\n    *, session: SessionDep, user_in: UserUpdateMe, current_user: CurrentUser\n) -> Any:\n    \"\"\"\n    Update own user.\n    \"\"\"\n\n    if user_in.email:\n        existing_user = crud.get_user_by_email(session=session, email=user_in.email)\n        if existing_user and existing_user.id != current_user.id:\n            raise HTTPException(\n                status_code=409, detail=\"User with this email already exists\"\n            )\n    user_data = user_in.model_dump(exclude_unset=True)\n    current_user.sqlmodel_update(user_data)\n    session.add(current_user)\n    session.commit()\n    session.refresh(current_user)\n    return current_user",
      "update_password_me": "def update_password_me(\n    *, session: SessionDep, body: UpdatePassword, current_user: CurrentUser\n) -> Any:\n    \"\"\"\n    Update own password.\n    \"\"\"\n    if not verify_password(body.current_password, current_user.hashed_password):\n        raise HTTPException(status_code=400, detail=\"Incorrect password\")\n    if body.current_password == body.new_password:\n        raise HTTPException(\n            status_code=400, detail=\"New password cannot be the same as the current one\"\n        )\n    hashed_password = get_password_hash(body.new_password)\n    current_user.hashed_password = hashed_password\n    session.add(current_user)\n    session.commit()\n    return Message(message=\"Password updated successfully\")",
      "read_user_me": "def read_user_me(current_user: CurrentUser) -> Any:\n    \"\"\"\n    Get current user.\n    \"\"\"\n    return current_user",
      "register_user": "def register_user(session: SessionDep, user_in: UserRegister) -> Any:\n    \"\"\"\n    Create new user without the need to be logged in.\n    \"\"\"\n    if not settings.USERS_OPEN_REGISTRATION:\n        raise HTTPException(\n            status_code=403,\n            detail=\"Open user registration is forbidden on this server\",\n        )\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system\",\n        )\n    user_create = UserCreate.model_validate(user_in)\n    user = crud.create_user(session=session, user_create=user_create)\n    return user",
      "read_user_by_id": "def read_user_by_id(\n    user_id: int, session: SessionDep, current_user: CurrentUser\n) -> Any:\n    \"\"\"\n    Get a specific user by id.\n    \"\"\"\n    user = session.get(User, user_id)\n    if user == current_user:\n        return user\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=403,\n            detail=\"The user doesn't have enough privileges\",\n        )\n    return user",
      "delete_user": "def delete_user(\n    session: SessionDep, current_user: CurrentUser, user_id: int\n) -> Message:\n    \"\"\"\n    Delete a user.\n    \"\"\"\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    elif user != current_user and not current_user.is_superuser:\n        raise HTTPException(\n            status_code=403, detail=\"The user doesn't have enough privileges\"\n        )\n    elif user == current_user and current_user.is_superuser:\n        raise HTTPException(\n            status_code=403, detail=\"Super users are not allowed to delete themselves\"\n        )\n\n    statement = delete(Item).where(col(Item.owner_id) == user_id)\n    session.exec(statement)  # type: ignore\n    session.delete(user)\n    session.commit()\n    return Message(message=\"User deleted successfully\")",
      "test_email": "def test_email(email_to: EmailStr) -> Message:\n    \"\"\"\n    Test emails.\n    \"\"\"\n    email_data = generate_test_email(email_to=email_to)\n    send_email(\n        email_to=email_to,\n        subject=email_data.subject,\n        html_content=email_data.html_content,\n    )\n    return Message(message=\"Test email sent\")",
      "login_access_token": "def login_access_token(\n    session: SessionDep, form_data: Annotated[OAuth2PasswordRequestForm, Depends()]\n) -> Token:\n    \"\"\"\n    OAuth2 compatible token login, get an access token for future requests\n    \"\"\"\n    user = crud.authenticate(\n        session=session, email=form_data.username, password=form_data.password\n    )\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    return Token(\n        access_token=security.create_access_token(\n            user.id, expires_delta=access_token_expires\n        )\n    )",
      "test_token": "def test_token(current_user: CurrentUser) -> Any:\n    \"\"\"\n    Test access token\n    \"\"\"\n    return current_user",
      "recover_password": "def recover_password(email: str, session: SessionDep) -> Message:\n    \"\"\"\n    Password Recovery\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this email does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    email_data = generate_reset_password_email(\n        email_to=user.email, email=email, token=password_reset_token\n    )\n    send_email(\n        email_to=user.email,\n        subject=email_data.subject,\n        html_content=email_data.html_content,\n    )\n    return Message(message=\"Password recovery email sent\")",
      "reset_password": "def reset_password(session: SessionDep, body: NewPassword) -> Message:\n    \"\"\"\n    Reset password\n    \"\"\"\n    email = verify_password_reset_token(token=body.token)\n    if not email:\n        raise HTTPException(status_code=400, detail=\"Invalid token\")\n    user = crud.get_user_by_email(session=session, email=email)\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this email does not exist in the system.\",\n        )\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    hashed_password = get_password_hash(password=body.new_password)\n    user.hashed_password = hashed_password\n    session.add(user)\n    session.commit()\n    return Message(message=\"Password updated successfully\")",
      "recover_password_html_content": "def recover_password_html_content(email: str, session: SessionDep) -> Any:\n    \"\"\"\n    HTML Content for Password Recovery\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    email_data = generate_reset_password_email(\n        email_to=user.email, email=email, token=password_reset_token\n    )\n\n    return HTMLResponse(\n        content=email_data.html_content, headers={\"subject:\": email_data.subject}\n    )",
      "read_items": "def read_items(\n    session: SessionDep, current_user: CurrentUser, skip: int = 0, limit: int = 100\n) -> Any:\n    \"\"\"\n    Retrieve items.\n    \"\"\"\n\n    if current_user.is_superuser:\n        count_statement = select(func.count()).select_from(Item)\n        count = session.exec(count_statement).one()\n        statement = select(Item).offset(skip).limit(limit)\n        items = session.exec(statement).all()\n    else:\n        count_statement = (\n            select(func.count())\n            .select_from(Item)\n            .where(Item.owner_id == current_user.id)\n        )\n        count = session.exec(count_statement).one()\n        statement = (\n            select(Item)\n            .where(Item.owner_id == current_user.id)\n            .offset(skip)\n            .limit(limit)\n        )\n        items = session.exec(statement).all()\n\n    return ItemsPublic(data=items, count=count)",
      "read_item": "def read_item(session: SessionDep, current_user: CurrentUser, id: int) -> Any:\n    \"\"\"\n    Get item by ID.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    return item",
      "update_item": "def update_item(\n    *, session: SessionDep, current_user: CurrentUser, id: int, item_in: ItemUpdate\n) -> Any:\n    \"\"\"\n    Update an item.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    update_dict = item_in.model_dump(exclude_unset=True)\n    item.sqlmodel_update(update_dict)\n    session.add(item)\n    session.commit()\n    session.refresh(item)\n    return item",
      "delete_item": "def delete_item(session: SessionDep, current_user: CurrentUser, id: int) -> Message:\n    \"\"\"\n    Delete an item.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    session.delete(item)\n    session.commit()\n    return Message(message=\"Item deleted successfully\")",
      "get_url": "def get_url():\n    user = os.getenv(\"POSTGRES_USER\", \"postgres\")\n    password = os.getenv(\"POSTGRES_PASSWORD\", \"\")\n    server = os.getenv(\"POSTGRES_SERVER\", \"db\")\n    port = os.getenv(\"POSTGRES_PORT\", \"5432\")\n    db = os.getenv(\"POSTGRES_DB\", \"app\")\n    return f\"postgresql+psycopg://{user}:{password}@{server}:{port}/{db}\"",
      "run_migrations_offline": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = get_url()\n    context.configure(\n        url=url, target_metadata=target_metadata, literal_binds=True, compare_type=True\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()",
      "run_migrations_online": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    configuration = config.get_section(config.config_ini_section)\n    configuration[\"sqlalchemy.url\"] = get_url()\n    connectable = engine_from_config(\n        configuration,\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata, compare_type=True\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()",
      "upgrade": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"user\",\n        sa.Column(\"email\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"is_active\", sa.Boolean(), nullable=False),\n        sa.Column(\"is_superuser\", sa.Boolean(), nullable=False),\n        sa.Column(\"full_name\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\n            \"hashed_password\", sqlmodel.sql.sqltypes.AutoString(), nullable=False\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_user_email\"), \"user\", [\"email\"], unique=True)\n    op.create_table(\n        \"item\",\n        sa.Column(\"description\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"title\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"owner_id\", sa.Integer(), nullable=False),\n        sa.ForeignKeyConstraint(\n            [\"owner_id\"],\n            [\"user.id\"],\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )",
      "downgrade": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table(\"item\")\n    op.drop_index(op.f(\"ix_user_email\"), table_name=\"user\")\n    op.drop_table(\"user\")"
    },
    "class_to_code": {
      "UserBase": [],
      "UserCreate": [],
      "UserRegister": [],
      "UserUpdate": [],
      "UserUpdateMe": [],
      "UpdatePassword": [],
      "User": [],
      "UserPublic": [],
      "UsersPublic": [],
      "ItemBase": [],
      "ItemCreate": [],
      "ItemUpdate": [],
      "Item": [],
      "ItemPublic": [],
      "ItemsPublic": [],
      "Message": [],
      "Token": [],
      "TokenPayload": [],
      "NewPassword": [],
      "EmailData": [],
      "Settings": []
    },
    "function_to_test": {
      "Session": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "init_db": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "delete": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "session.execute": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "session.commit": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "pytest.fixture": [
        "def normal_user_token_headers(client: TestClient, db: Session) -> dict[str, str]:\n    return authentication_token_from_email(\n        client=client, email=settings.EMAIL_TEST_USER, db=db\n    )"
      ],
      "TestClient": [
        "def client() -> Generator[TestClient, None, None]:\n    with TestClient(app) as c:\n        yield c"
      ],
      "get_superuser_token_headers": [
        "def superuser_token_headers(client: TestClient) -> dict[str, str]:\n    return get_superuser_token_headers(client)"
      ],
      "authentication_token_from_email": [
        "def normal_user_token_headers(client: TestClient, db: Session) -> dict[str, str]:\n    return authentication_token_from_email(\n        client=client, email=settings.EMAIL_TEST_USER, db=db\n    )"
      ],
      "client.post": [
        "def user_authentication_headers(\n    *, client: TestClient, email: str, password: str\n) -> dict[str, str]:\n    data = {\"username\": email, \"password\": password}\n\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=data)\n    response = r.json()\n    auth_token = response[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    return headers",
        "def get_superuser_token_headers(client: TestClient) -> dict[str, str]:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n    return headers",
        "def test_reset_password_invalid_token(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"new_password\": \"changethis\", \"token\": \"invalid\"}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    response = r.json()\n\n    assert \"detail\" in response\n    assert r.status_code == 400\n    assert response[\"detail\"] == \"Invalid token\"",
        "def test_create_item(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"title\": \"Foo\", \"description\": \"Fighters\"}\n    response = client.post(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert content[\"title\"] == data[\"title\"]\n    assert content[\"description\"] == data[\"description\"]\n    assert \"id\" in content\n    assert \"owner_id\" in content",
        "def test_delete_user_current_user(client: TestClient, db: Session) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_id = user.id\n\n    login_data = {\n        \"username\": username,\n        \"password\": password,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=headers,\n    )\n    assert r.status_code == 200\n    deleted_user = r.json()\n    assert deleted_user[\"message\"] == \"User deleted successfully\""
      ],
      "r.json": [
        "def user_authentication_headers(\n    *, client: TestClient, email: str, password: str\n) -> dict[str, str]:\n    data = {\"username\": email, \"password\": password}\n\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=data)\n    response = r.json()\n    auth_token = response[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    return headers",
        "def get_superuser_token_headers(client: TestClient) -> dict[str, str]:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n    return headers",
        "def test_reset_password_invalid_token(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"new_password\": \"changethis\", \"token\": \"invalid\"}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    response = r.json()\n\n    assert \"detail\" in response\n    assert r.status_code == 400\n    assert response[\"detail\"] == \"Invalid token\"",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "random_email": [
        "def create_random_user(db: Session) -> User:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    return user",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "random_lower_string": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def random_email() -> str:\n    return f\"{random_lower_string()}@{random_lower_string()}.com\"",
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "UserCreate": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "crud.create_user": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "crud.get_user_by_email": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_delete_user_current_super_user_error(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    super_user = crud.get_user_by_email(session=db, email=settings.FIRST_SUPERUSER)\n    assert super_user\n    user_id = super_user.id\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=superuser_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"Super users are not allowed to delete themselves\""
      ],
      "UserUpdate": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "Exception": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)"
      ],
      "crud.update_user": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "user_authentication_headers": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)"
      ],
      "random.choices": [
        "def random_lower_string() -> str:\n    return \"\".join(random.choices(string.ascii_lowercase, k=32))"
      ],
      "create_random_user": [
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)"
      ],
      "ItemCreate": [
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)"
      ],
      "crud.create_item": [
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)"
      ],
      "MagicMock": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "session_mock.configure_mock": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "patch": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_recovery_password(\n    client: TestClient, normal_user_token_headers: dict[str, str]\n) -> None:\n    with (\n        patch(\"app.core.config.settings.SMTP_HOST\", \"smtp.example.com\"),\n        patch(\"app.core.config.settings.SMTP_USER\", \"admin@example.com\"),\n    ):\n        email = \"test@example.com\"\n        r = client.post(\n            f\"{settings.API_V1_STR}/password-recovery/{email}\",\n            headers=normal_user_token_headers,\n        )\n        assert r.status_code == 200\n        assert r.json() == {\"message\": \"Password recovery email sent\"}",
        "def test_register_user_already_exists_error(client: TestClient) -> None:\n    with patch(\"app.core.config.settings.USERS_OPEN_REGISTRATION\", True):\n        password = random_lower_string()\n        full_name = random_lower_string()\n        data = {\n            \"email\": settings.FIRST_SUPERUSER,\n            \"password\": password,\n            \"full_name\": full_name,\n        }\n        r = client.post(\n            f\"{settings.API_V1_STR}/users/signup\",\n            json=data,\n        )\n        assert r.status_code == 400\n        assert (\n            r.json()[\"detail\"]\n            == \"The user with this email already exists in the system\"\n        )"
      ],
      "patch.object": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "init": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "select": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "hasattr": [
        "def test_create_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    assert user.email == email\n    assert hasattr(user, \"hashed_password\")"
      ],
      "crud.authenticate": [
        "def test_not_authenticate_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user = crud.authenticate(session=db, email=email, password=password)\n    assert user is None"
      ],
      "db.get": [
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "jsonable_encoder": [
        "def test_get_user(db: Session) -> None:\n    password = random_lower_string()\n    username = random_email()\n    user_in = UserCreate(email=username, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert jsonable_encoder(user) == jsonable_encoder(user_2)"
      ],
      "verify_password": [
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "generate_password_reset_token": [
        "def test_reset_password(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    token = generate_password_reset_token(email=settings.FIRST_SUPERUSER)\n    data = {\"new_password\": \"changethis\", \"token\": token}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    assert r.json() == {\"message\": \"Password updated successfully\"}"
      ],
      "response.json": [
        "def test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\""
      ],
      "create_random_item": [
        "def test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\""
      ],
      "client.get": [
        "def test_read_items(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    create_random_item(db)\n    create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert len(content[\"data\"]) >= 2",
        "def test_retrieve_users(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    crud.create_user(session=db, user_create=user_in2)\n\n    r = client.get(f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers)\n    all_users = r.json()\n\n    assert len(all_users[\"data\"]) > 1\n    assert \"count\" in all_users\n    for item in all_users[\"data\"]:\n        assert \"email\" in item"
      ],
      "len": [
        "def test_read_items(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    create_random_item(db)\n    create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert len(content[\"data\"]) >= 2",
        "def test_retrieve_users(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    crud.create_user(session=db, user_create=user_in2)\n\n    r = client.get(f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers)\n    all_users = r.json()\n\n    assert len(all_users[\"data\"]) > 1\n    assert \"count\" in all_users\n    for item in all_users[\"data\"]:\n        assert \"email\" in item"
      ],
      "client.put": [
        "def test_update_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    data = {\"title\": \"Updated title\", \"description\": \"Updated description\"}\n    response = client.put(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n        json=data,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\""
      ],
      "client.delete": [
        "def test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\"",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "client.patch": [
        "def test_update_user_email_exists(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    user2 = crud.create_user(session=db, user_create=user_in2)\n\n    data = {\"email\": user2.email}\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 409\n    assert r.json()[\"detail\"] == \"User with this email already exists\""
      ]
    },
    "files": [],
    "readme": {
      "text": "# FastAPI Project - Backend\n\n## Requirements\n\n* [Docker](https://www.docker.com/).\n* [Poetry](https://python-poetry.org/) for Python package and environment management.\n\n## Local Development\n\n* Start the stack with Docker Compose:\n\n```bash\ndocker compose up -d\n```\n\n* Now you can open your browser and interact with these URLs:\n\nFrontend, built with Docker, with routes handled based on the path: http://localhost\n\nBackend, JSON based web API based on OpenAPI: http://localhost/api/\n\nAutomatic interactive documentation with Swagger UI (from the OpenAPI backend): http://localhost/docs\n\nAdminer, database web administration: http://localhost:8080\n\nTraefik UI, to see how the routes are being handled by the proxy: http://localhost:8090\n\n**Note**: The first time you start your stack, it might take a minute for it to be ready. While the backend waits for the database to be ready and configures everything. You can check the logs to monitor it.\n\nTo check the logs, run:\n\n```bash\ndocker compose logs\n```\n\nTo check the logs of a specific service, add the name of the service, e.g.:\n\n```bash\ndocker compose logs backend\n```\n\nIf your Docker is not running in `localhost` (the URLs above wouldn't work) you would need to use the IP or domain where your Docker is running.\n\n## Backend local development, additional details\n\n### General workflow\n\nBy default, the dependencies are managed with [Poetry](https://python-poetry.org/), go there and install it.\n\nFrom `./backend/` you can install all the dependencies with:\n\n```console\n$ poetry install\n```\n\nThen you can start a shell session with the new environment with:\n\n```console\n$ poetry shell\n```\n\nMake sure your editor is using the correct Python virtual environment.\n\nModify or add SQLModel models for data and SQL tables in `./backend/app/models.py`, API endpoints in `./backend/app/api/`, CRUD (Create, Read, Update, Delete) utils in `./backend/app/crud.py`.\n\n### VS Code\n\nThere are already configurations in place to run the backend through the VS Code debugger, so that you can use breakpoints, pause and explore variables, etc.\n\nThe setup is also already configured so you can run the tests through the VS Code Python tests tab.\n\n### Docker Compose Override\n\nDuring development, you can change Docker Compose settings that will only affect the local development environment in the file `docker-compose.override.yml`.\n\nThe changes to that file only affect the local development environment, not the production environment. So, you can add \"temporary\" changes that help the development workflow.\n\nFor example, the directory with the backend code is mounted as a Docker \"host volume\", mapping the code you change live to the directory inside the container. That allows you to test your changes right away, without having to build the Docker image again. It should only be done during development, for production, you should build the Docker image with a recent version of the backend code. But during development, it allows you to iterate very fast.\n\nThere is also a command override that runs `/start-reload.sh` (included in the base image) instead of the default `/start.sh` (also included in the base image). It starts a single server process (instead of multiple, as would be for production) and reloads the process whenever the code changes. Have in mind that if you have a syntax error and save the Python file, it will break and exit, and the container will stop. After that, you can restart the container by fixing the error and running again:\n\n```console\n$ docker compose up -d\n```\n\nThere is also a commented out `command` override, you can uncomment it and comment the default one. It makes the backend container run a process that does \"nothing\", but keeps the container alive. That allows you to get inside your running container and execute commands inside, for example a Python interpreter to test installed dependencies, or start the development server that reloads when it detects changes.\n\nTo get inside the container with a `bash` session you can start the stack with:\n\n```console\n$ docker compose up -d\n```\n\nand then `exec` inside the running container:\n\n```console\n$ docker compose exec backend bash\n```\n\nYou should see an output like:\n\n```console\nroot@7f2607af31c3:/app#\n```\n\nthat means that you are in a `bash` session inside your container, as a `root` user, under the `/app` directory, this directory has another directory called \"app\" inside, that's where your code lives inside the container: `/app/app`.\n\nThere you can use the script `/start-reload.sh` to run the debug live reloading server. You can run that script from inside the container with:\n\n```console\n$ bash /start-reload.sh\n```\n\n...it will look like:\n\n```console\nroot@7f2607af31c3:/app# bash /start-reload.sh\n```\n\nand then hit enter. That runs the live reloading server that auto reloads when it detects code changes.\n\nNevertheless, if it doesn't detect a change but a syntax error, it will just stop with an error. But as the container is still alive and you are in a Bash session, you can quickly restart it after fixing the error, running the same command (\"up arrow\" and \"Enter\").\n\n...this previous detail is what makes it useful to have the container alive doing nothing and then, in a Bash session, make it run the live reload server.\n\n### Backend tests\n\nTo test the backend run:\n\n```console\n$ bash ./scripts/test.sh\n```\n\nThe tests run with Pytest, modify and add tests to `./backend/app/tests/`.\n\nIf you use GitHub Actions the tests will run automatically.\n\n#### Test running stack\n\nIf your stack is already up and you just want to run the tests, you can use:\n\n```bash\ndocker compose exec backend bash /app/tests-start.sh\n```\n\nThat `/app/tests-start.sh` script just calls `pytest` after making sure that the rest of the stack is running. If you need to pass extra arguments to `pytest`, you can pass them to that command and they will be forwarded.\n\nFor example, to stop on first error:\n\n```bash\ndocker compose exec backend bash /app/tests-start.sh -x\n```\n\n#### Test Coverage\n\nWhen the tests are run, a file `htmlcov/index.html` is generated, you can open it in your browser to see the coverage of the tests.\n\n### Migrations\n\nAs during local development your app directory is mounted as a volume inside the container, you can also run the migrations with `alembic` commands inside the container and the migration code will be in your app directory (instead of being only inside the container). So you can add it to your git repository.\n\nMake sure you create a \"revision\" of your models and that you \"upgrade\" your database with that revision every time you change them. As this is what will update the tables in your database. Otherwise, your application will have errors.\n\n* Start an interactive session in the backend container:\n\n```console\n$ docker compose exec backend bash\n```\n\n* Alembic is already configured to import your SQLModel models from `./backend/app/models.py`.\n\n* After changing a model (for example, adding a column), inside the container, create a revision, e.g.:\n\n```console\n$ alembic revision --autogenerate -m \"Add column last_name to User model\"\n```\n\n* Commit to the git repository the files generated in the alembic directory.\n\n* After creating the revision, run the migration in the database (this is what will actually change the database):\n\n```console\n$ alembic upgrade head\n```\n\nIf you don't want to use migrations at all, uncomment the lines in the file at `./backend/app/core/db.py` that end in:\n\n```python\nSQLModel.metadata.create_all(engine)\n```\n\nand comment the line in the file `prestart.sh` that contains:\n\n```console\n$ alembic upgrade head\n```\n\nIf you don't want to start with the default models and want to remove them / modify them, from the beginning, without having any previous revision, you can remove the revision files (`.py` Python files) under `./backend/app/alembic/versions/`. And then create a first migration as described above.\n\n\nGeneric single-database configuration.\n\n\n",
      "summary": " "
    },
    "functions": [],
    "class_data": " ",
    "class_data_comments": [
      {
        "name": "UserBase",
        "content": " "
      },
      {
        "name": "UserCreate",
        "content": " "
      },
      {
        "name": "UserRegister",
        "content": " "
      },
      {
        "name": "UserUpdate",
        "content": " "
      },
      {
        "name": "UserUpdateMe",
        "content": " "
      },
      {
        "name": "UpdatePassword",
        "content": " "
      },
      {
        "name": "User",
        "content": " "
      },
      {
        "name": "UserPublic",
        "content": " "
      },
      {
        "name": "UsersPublic",
        "content": " "
      },
      {
        "name": "ItemBase",
        "content": " "
      },
      {
        "name": "ItemCreate",
        "content": " "
      },
      {
        "name": "ItemUpdate",
        "content": " "
      },
      {
        "name": "Item",
        "content": " "
      },
      {
        "name": "ItemPublic",
        "content": " "
      },
      {
        "name": "ItemsPublic",
        "content": " "
      },
      {
        "name": "Message",
        "content": " "
      },
      {
        "name": "Token",
        "content": " "
      },
      {
        "name": "TokenPayload",
        "content": " "
      },
      {
        "name": "NewPassword",
        "content": " "
      },
      {
        "name": "EmailData",
        "content": " "
      },
      {
        "name": "Settings",
        "content": " "
      }
    ],
    "project_structure": "{\"root\": {\"dirs\": {\"app\": {}, \"scripts\": {}}, \"files\": {}}, \"app\": {\"dirs\": {\"core\": {}, \"email-templates\": {}, \"tests\": {}, \"api\": {}, \"alembic\": {}}, \"files\": {\"models.py\": [], \"backend_pre_start.py\": [], \"initial_data.py\": [], \"__init__.py\": [], \"utils.py\": [\"send_email\", \"generate_test_email\", \"generate_reset_password_email\", \"generate_new_account_email\", \"generate_password_reset_token\", \"verify_password_reset_token\"], \"tests_pre_start.py\": [], \"main.py\": [], \"crud.py\": [\"create_user\", \"get_user_by_email\", \"authenticate\"]}}, \"app/core\": {\"dirs\": {}, \"files\": {\"db.py\": [], \"config.py\": [], \"security.py\": [\"create_access_token\", \"verify_password\", \"get_password_hash\"], \"__init__.py\": []}}, \"app/email-templates\": {\"dirs\": {\"build\": {}, \"src\": {}}, \"files\": {}}, \"app/email-templates/build\": {\"dirs\": {}, \"files\": {}}, \"app/email-templates/src\": {\"dirs\": {}, \"files\": {}}, \"app/tests\": {\"dirs\": {\"utils\": {}, \"scripts\": {}, \"crud\": {}, \"api\": {}}, \"files\": {\"conftest.py\": [], \"__init__.py\": []}}, \"app/tests/utils\": {\"dirs\": {}, \"files\": {\"user.py\": [], \"__init__.py\": [], \"utils.py\": [], \"item.py\": []}}, \"app/tests/scripts\": {\"dirs\": {}, \"files\": {\"__init__.py\": [], \"test_backend_pre_start.py\": [], \"test_test_pre_start.py\": []}}, \"app/tests/crud\": {\"dirs\": {}, \"files\": {\"test_user.py\": [], \"__init__.py\": []}}, \"app/tests/api\": {\"dirs\": {\"routes\": {}}, \"files\": {\"__init__.py\": []}}, \"app/tests/api/routes\": {\"dirs\": {}, \"files\": {\"test_login.py\": [], \"__init__.py\": [], \"test_items.py\": [], \"test_users.py\": []}}, \"app/api\": {\"dirs\": {\"routes\": {}}, \"files\": {\"deps.py\": [], \"__init__.py\": [], \"main.py\": []}}, \"app/api/routes\": {\"dirs\": {}, \"files\": {\"users.py\": [\"create_user\"], \"__init__.py\": [], \"utils.py\": [], \"login.py\": [], \"items.py\": []}}, \"app/alembic\": {\"dirs\": {\"versions\": {}}, \"files\": {\"env.py\": []}}, \"app/alembic/versions\": {\"dirs\": {}, \"files\": {\"e2412789c190_initialize_models.py\": []}}, \"scripts\": {\"dirs\": {}, \"files\": {}}}",
    "business_stories": []
  }
}