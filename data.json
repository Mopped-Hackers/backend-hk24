{
  "KAPPA": {
    "function_to_code": {
      "init": "def init(db_engine: Engine) -> None:\n    try:\n        # Try to create session to check if DB is awake\n        with Session(db_engine) as session:\n            session.exec(select(1))\n    except Exception as e:\n        logger.error(e)\n        raise e",
      "main": "def main() -> None:\n    logger.info(\"Initializing service\")\n    init(engine)\n    logger.info(\"Service finished initializing\")",
      "render_email_template": "def render_email_template(*, template_name: str, context: dict[str, Any]) -> str:\n    template_str = (\n        Path(__file__).parent / \"email-templates\" / \"build\" / template_name\n    ).read_text()\n    html_content = Template(template_str).render(context)\n    return html_content",
      "send_email": "def send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")",
      "generate_test_email": "def generate_test_email(email_to: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Test email\"\n    html_content = render_email_template(\n        template_name=\"test_email.html\",\n        context={\"project_name\": settings.PROJECT_NAME, \"email\": email_to},\n    )\n    return EmailData(html_content=html_content, subject=subject)",
      "generate_reset_password_email": "def generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
      "generate_new_account_email": "def generate_new_account_email(\n    email_to: str, username: str, password: str\n) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - New account for user {username}\"\n    html_content = render_email_template(\n        template_name=\"new_account.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": settings.server_host,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
      "generate_password_reset_token": "def generate_password_reset_token(email: str) -> str:\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt",
      "verify_password_reset_token": "def verify_password_reset_token(token: str) -> str | None:\n    try:\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        return str(decoded_token[\"sub\"])\n    except JWTError:\n        return None",
      "custom_generate_unique_id": "def custom_generate_unique_id(route: APIRoute) -> str:\n    return f\"{route.tags[0]}-{route.name}\"",
      "create_user": "def create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    return user",
      "update_user": "def update_user(\n    *,\n    session: SessionDep,\n    user_id: int,\n    user_in: UserUpdate,\n) -> Any:\n    \"\"\"\n    Update a user.\n    \"\"\"\n\n    db_user = session.get(User, user_id)\n    if not db_user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this id does not exist in the system\",\n        )\n    if user_in.email:\n        existing_user = crud.get_user_by_email(session=session, email=user_in.email)\n        if existing_user and existing_user.id != user_id:\n            raise HTTPException(\n                status_code=409, detail=\"User with this email already exists\"\n            )\n\n    db_user = crud.update_user(session=session, db_user=db_user, user_in=user_in)\n    return db_user",
      "get_user_by_email": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
      "authenticate": "def authenticate(*, session: Session, email: str, password: str) -> User | None:\n    db_user = get_user_by_email(session=session, email=email)\n    if not db_user:\n        return None\n    if not verify_password(password, db_user.hashed_password):\n        return None\n    return db_user",
      "create_item": "def create_item(\n    *, session: SessionDep, current_user: CurrentUser, item_in: ItemCreate\n) -> Any:\n    \"\"\"\n    Create new item.\n    \"\"\"\n    item = Item.model_validate(item_in, update={\"owner_id\": current_user.id})\n    session.add(item)\n    session.commit()\n    session.refresh(item)\n    return item",
      "init_db": "def init_db(session: Session) -> None:\n    # Tables should be created with Alembic migrations\n    # But if you don't want to use migrations, create\n    # the tables un-commenting the next lines\n    # from sqlmodel import SQLModel\n\n    # from app.core.engine import engine\n    # This works because the models are already imported and registered from app.models\n    # SQLModel.metadata.create_all(engine)\n\n    user = session.exec(\n        select(User).where(User.email == settings.FIRST_SUPERUSER)\n    ).first()\n    if not user:\n        user_in = UserCreate(\n            email=settings.FIRST_SUPERUSER,\n            password=settings.FIRST_SUPERUSER_PASSWORD,\n            is_superuser=True,\n        )\n        user = crud.create_user(session=session, user_create=user_in)",
      "parse_cors": "def parse_cors(v: Any) -> list[str] | str:\n    if isinstance(v, str) and not v.startswith(\"[\"):\n        return [i.strip() for i in v.split(\",\")]\n    elif isinstance(v, list | str):\n        return v\n    raise ValueError(v)",
      "server_host": "def server_host(self) -> str:\n        # Use HTTPS for anything other than local development\n        if self.ENVIRONMENT == \"local\":\n            return f\"http://{self.DOMAIN}\"\n        return f\"https://{self.DOMAIN}\"",
      "SQLALCHEMY_DATABASE_URI": "def SQLALCHEMY_DATABASE_URI(self) -> PostgresDsn:\n        return MultiHostUrl.build(\n            scheme=\"postgresql+psycopg\",\n            username=self.POSTGRES_USER,\n            password=self.POSTGRES_PASSWORD,\n            host=self.POSTGRES_SERVER,\n            port=self.POSTGRES_PORT,\n            path=self.POSTGRES_DB,\n        )",
      "_set_default_emails_from": "def _set_default_emails_from(self) -> Self:\n        if not self.EMAILS_FROM_NAME:\n            self.EMAILS_FROM_NAME = self.PROJECT_NAME\n        return self",
      "emails_enabled": "def emails_enabled(self) -> bool:\n        return bool(self.SMTP_HOST and self.EMAILS_FROM_EMAIL)",
      "_check_default_secret": "def _check_default_secret(self, var_name: str, value: str | None) -> None:\n        if value == \"changethis\":\n            message = (\n                f'The value of {var_name} is \"changethis\", '\n                \"for security, please change it, at least for deployments.\"\n            )\n            if self.ENVIRONMENT == \"local\":\n                warnings.warn(message, stacklevel=1)\n            else:\n                raise ValueError(message)",
      "_enforce_non_default_secrets": "def _enforce_non_default_secrets(self) -> Self:\n        self._check_default_secret(\"SECRET_KEY\", self.SECRET_KEY)\n        self._check_default_secret(\"POSTGRES_PASSWORD\", self.POSTGRES_PASSWORD)\n        self._check_default_secret(\n            \"FIRST_SUPERUSER_PASSWORD\", self.FIRST_SUPERUSER_PASSWORD\n        )\n\n        return self",
      "create_access_token": "def create_access_token(subject: str | Any, expires_delta: timedelta) -> str:\n    expire = datetime.utcnow() + expires_delta\n    to_encode = {\"exp\": expire, \"sub\": str(subject)}\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt",
      "verify_password": "def verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)",
      "get_password_hash": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)",
      "get_db": "def get_db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        yield session",
      "get_current_user": "def get_current_user(session: SessionDep, token: TokenDep) -> User:\n    try:\n        payload = jwt.decode(\n            token, settings.SECRET_KEY, algorithms=[security.ALGORITHM]\n        )\n        token_data = TokenPayload(**payload)\n    except (JWTError, ValidationError):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials\",\n        )\n    user = session.get(User, token_data.sub)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    if not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return user",
      "get_current_active_superuser": "def get_current_active_superuser(current_user: CurrentUser) -> User:\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=400, detail=\"The user doesn't have enough privileges\"\n        )\n    return current_user",
      "read_users": "def read_users(session: SessionDep, skip: int = 0, limit: int = 100) -> Any:\n    \"\"\"\n    Retrieve users.\n    \"\"\"\n\n    count_statement = select(func.count()).select_from(User)\n    count = session.exec(count_statement).one()\n\n    statement = select(User).offset(skip).limit(limit)\n    users = session.exec(statement).all()\n\n    return UsersOut(data=users, count=count)",
      "update_user_me": "def update_user_me(\n    *, session: SessionDep, user_in: UserUpdateMe, current_user: CurrentUser\n) -> Any:\n    \"\"\"\n    Update own user.\n    \"\"\"\n\n    if user_in.email:\n        existing_user = crud.get_user_by_email(session=session, email=user_in.email)\n        if existing_user and existing_user.id != current_user.id:\n            raise HTTPException(\n                status_code=409, detail=\"User with this email already exists\"\n            )\n    user_data = user_in.model_dump(exclude_unset=True)\n    current_user.sqlmodel_update(user_data)\n    session.add(current_user)\n    session.commit()\n    session.refresh(current_user)\n    return current_user",
      "update_password_me": "def update_password_me(\n    *, session: SessionDep, body: UpdatePassword, current_user: CurrentUser\n) -> Any:\n    \"\"\"\n    Update own password.\n    \"\"\"\n    if not verify_password(body.current_password, current_user.hashed_password):\n        raise HTTPException(status_code=400, detail=\"Incorrect password\")\n    if body.current_password == body.new_password:\n        raise HTTPException(\n            status_code=400, detail=\"New password cannot be the same as the current one\"\n        )\n    hashed_password = get_password_hash(body.new_password)\n    current_user.hashed_password = hashed_password\n    session.add(current_user)\n    session.commit()\n    return Message(message=\"Password updated successfully\")",
      "read_user_me": "def read_user_me(current_user: CurrentUser) -> Any:\n    \"\"\"\n    Get current user.\n    \"\"\"\n    return current_user",
      "register_user": "def register_user(session: SessionDep, user_in: UserRegister) -> Any:\n    \"\"\"\n    Create new user without the need to be logged in.\n    \"\"\"\n    if not settings.USERS_OPEN_REGISTRATION:\n        raise HTTPException(\n            status_code=403,\n            detail=\"Open user registration is forbidden on this server\",\n        )\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system\",\n        )\n    user_create = UserCreate.model_validate(user_in)\n    user = crud.create_user(session=session, user_create=user_create)\n    return user",
      "read_user_by_id": "def read_user_by_id(\n    user_id: int, session: SessionDep, current_user: CurrentUser\n) -> Any:\n    \"\"\"\n    Get a specific user by id.\n    \"\"\"\n    user = session.get(User, user_id)\n    if user == current_user:\n        return user\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=403,\n            detail=\"The user doesn't have enough privileges\",\n        )\n    return user",
      "delete_user": "def delete_user(\n    session: SessionDep, current_user: CurrentUser, user_id: int\n) -> Message:\n    \"\"\"\n    Delete a user.\n    \"\"\"\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    elif user != current_user and not current_user.is_superuser:\n        raise HTTPException(\n            status_code=403, detail=\"The user doesn't have enough privileges\"\n        )\n    elif user == current_user and current_user.is_superuser:\n        raise HTTPException(\n            status_code=403, detail=\"Super users are not allowed to delete themselves\"\n        )\n\n    statement = delete(Item).where(col(Item.owner_id) == user_id)\n    session.exec(statement)  # type: ignore\n    session.delete(user)\n    session.commit()\n    return Message(message=\"User deleted successfully\")",
      "test_email": "def test_email(email_to: EmailStr) -> Message:\n    \"\"\"\n    Test emails.\n    \"\"\"\n    email_data = generate_test_email(email_to=email_to)\n    send_email(\n        email_to=email_to,\n        subject=email_data.subject,\n        html_content=email_data.html_content,\n    )\n    return Message(message=\"Test email sent\")",
      "login_access_token": "def login_access_token(\n    session: SessionDep, form_data: Annotated[OAuth2PasswordRequestForm, Depends()]\n) -> Token:\n    \"\"\"\n    OAuth2 compatible token login, get an access token for future requests\n    \"\"\"\n    user = crud.authenticate(\n        session=session, email=form_data.username, password=form_data.password\n    )\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    return Token(\n        access_token=security.create_access_token(\n            user.id, expires_delta=access_token_expires\n        )\n    )",
      "test_token": "def test_token(current_user: CurrentUser) -> Any:\n    \"\"\"\n    Test access token\n    \"\"\"\n    return current_user",
      "recover_password": "def recover_password(email: str, session: SessionDep) -> Message:\n    \"\"\"\n    Password Recovery\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this email does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    email_data = generate_reset_password_email(\n        email_to=user.email, email=email, token=password_reset_token\n    )\n    send_email(\n        email_to=user.email,\n        subject=email_data.subject,\n        html_content=email_data.html_content,\n    )\n    return Message(message=\"Password recovery email sent\")",
      "reset_password": "def reset_password(session: SessionDep, body: NewPassword) -> Message:\n    \"\"\"\n    Reset password\n    \"\"\"\n    email = verify_password_reset_token(token=body.token)\n    if not email:\n        raise HTTPException(status_code=400, detail=\"Invalid token\")\n    user = crud.get_user_by_email(session=session, email=email)\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this email does not exist in the system.\",\n        )\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    hashed_password = get_password_hash(password=body.new_password)\n    user.hashed_password = hashed_password\n    session.add(user)\n    session.commit()\n    return Message(message=\"Password updated successfully\")",
      "recover_password_html_content": "def recover_password_html_content(email: str, session: SessionDep) -> Any:\n    \"\"\"\n    HTML Content for Password Recovery\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    email_data = generate_reset_password_email(\n        email_to=user.email, email=email, token=password_reset_token\n    )\n\n    return HTMLResponse(\n        content=email_data.html_content, headers={\"subject:\": email_data.subject}\n    )",
      "read_items": "def read_items(\n    session: SessionDep, current_user: CurrentUser, skip: int = 0, limit: int = 100\n) -> Any:\n    \"\"\"\n    Retrieve items.\n    \"\"\"\n\n    if current_user.is_superuser:\n        count_statement = select(func.count()).select_from(Item)\n        count = session.exec(count_statement).one()\n        statement = select(Item).offset(skip).limit(limit)\n        items = session.exec(statement).all()\n    else:\n        count_statement = (\n            select(func.count())\n            .select_from(Item)\n            .where(Item.owner_id == current_user.id)\n        )\n        count = session.exec(count_statement).one()\n        statement = (\n            select(Item)\n            .where(Item.owner_id == current_user.id)\n            .offset(skip)\n            .limit(limit)\n        )\n        items = session.exec(statement).all()\n\n    return ItemsOut(data=items, count=count)",
      "read_item": "def read_item(session: SessionDep, current_user: CurrentUser, id: int) -> Any:\n    \"\"\"\n    Get item by ID.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    return item",
      "update_item": "def update_item(\n    *, session: SessionDep, current_user: CurrentUser, id: int, item_in: ItemUpdate\n) -> Any:\n    \"\"\"\n    Update an item.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    update_dict = item_in.model_dump(exclude_unset=True)\n    item.sqlmodel_update(update_dict)\n    session.add(item)\n    session.commit()\n    session.refresh(item)\n    return item",
      "delete_item": "def delete_item(session: SessionDep, current_user: CurrentUser, id: int) -> Message:\n    \"\"\"\n    Delete an item.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    session.delete(item)\n    session.commit()\n    return Message(message=\"Item deleted successfully\")",
      "get_url": "def get_url():\n    user = os.getenv(\"POSTGRES_USER\", \"postgres\")\n    password = os.getenv(\"POSTGRES_PASSWORD\", \"\")\n    server = os.getenv(\"POSTGRES_SERVER\", \"db\")\n    port = os.getenv(\"POSTGRES_PORT\", \"5432\")\n    db = os.getenv(\"POSTGRES_DB\", \"app\")\n    return f\"postgresql+psycopg://{user}:{password}@{server}:{port}/{db}\"",
      "run_migrations_offline": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = get_url()\n    context.configure(\n        url=url, target_metadata=target_metadata, literal_binds=True, compare_type=True\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()",
      "run_migrations_online": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    configuration = config.get_section(config.config_ini_section)\n    configuration[\"sqlalchemy.url\"] = get_url()\n    connectable = engine_from_config(\n        configuration,\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata, compare_type=True\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()",
      "upgrade": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"user\",\n        sa.Column(\"email\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"is_active\", sa.Boolean(), nullable=False),\n        sa.Column(\"is_superuser\", sa.Boolean(), nullable=False),\n        sa.Column(\"full_name\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\n            \"hashed_password\", sqlmodel.sql.sqltypes.AutoString(), nullable=False\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_user_email\"), \"user\", [\"email\"], unique=True)\n    op.create_table(\n        \"item\",\n        sa.Column(\"description\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"title\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"owner_id\", sa.Integer(), nullable=False),\n        sa.ForeignKeyConstraint(\n            [\"owner_id\"],\n            [\"user.id\"],\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )",
      "downgrade": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table(\"item\")\n    op.drop_index(op.f(\"ix_user_email\"), table_name=\"user\")\n    op.drop_table(\"user\")"
    },
    "class_to_code": {
      "UserBase": [],
      "UserCreate": [],
      "UserRegister": [],
      "UserUpdate": [],
      "UserUpdateMe": [],
      "UpdatePassword": [],
      "User": [],
      "UserOut": [],
      "UsersOut": [],
      "ItemBase": [],
      "ItemCreate": [],
      "ItemUpdate": [],
      "Item": [],
      "ItemOut": [],
      "ItemsOut": [],
      "Message": [],
      "Token": [],
      "TokenPayload": [],
      "NewPassword": [],
      "EmailData": [],
      "Settings": []
    },
    "function_to_test": {
      "Session": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "init_db": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "delete": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "session.execute": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "session.commit": [
        "def db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()"
      ],
      "pytest.fixture": [
        "def normal_user_token_headers(client: TestClient, db: Session) -> dict[str, str]:\n    return authentication_token_from_email(\n        client=client, email=settings.EMAIL_TEST_USER, db=db\n    )"
      ],
      "TestClient": [
        "def client() -> Generator[TestClient, None, None]:\n    with TestClient(app) as c:\n        yield c"
      ],
      "get_superuser_token_headers": [
        "def superuser_token_headers(client: TestClient) -> dict[str, str]:\n    return get_superuser_token_headers(client)"
      ],
      "authentication_token_from_email": [
        "def normal_user_token_headers(client: TestClient, db: Session) -> dict[str, str]:\n    return authentication_token_from_email(\n        client=client, email=settings.EMAIL_TEST_USER, db=db\n    )"
      ],
      "client.post": [
        "def user_authentication_headers(\n    *, client: TestClient, email: str, password: str\n) -> dict[str, str]:\n    data = {\"username\": email, \"password\": password}\n\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=data)\n    response = r.json()\n    auth_token = response[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    return headers",
        "def get_superuser_token_headers(client: TestClient) -> dict[str, str]:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n    return headers",
        "def test_reset_password_invalid_token(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"new_password\": \"changethis\", \"token\": \"invalid\"}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    response = r.json()\n\n    assert \"detail\" in response\n    assert r.status_code == 400\n    assert response[\"detail\"] == \"Invalid token\"",
        "def test_create_item(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"title\": \"Foo\", \"description\": \"Fighters\"}\n    response = client.post(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert content[\"title\"] == data[\"title\"]\n    assert content[\"description\"] == data[\"description\"]\n    assert \"id\" in content\n    assert \"owner_id\" in content",
        "def test_delete_user_current_user(client: TestClient, db: Session) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_id = user.id\n\n    login_data = {\n        \"username\": username,\n        \"password\": password,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=headers,\n    )\n    assert r.status_code == 200\n    deleted_user = r.json()\n    assert deleted_user[\"message\"] == \"User deleted successfully\""
      ],
      "r.json": [
        "def user_authentication_headers(\n    *, client: TestClient, email: str, password: str\n) -> dict[str, str]:\n    data = {\"username\": email, \"password\": password}\n\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=data)\n    response = r.json()\n    auth_token = response[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    return headers",
        "def get_superuser_token_headers(client: TestClient) -> dict[str, str]:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n    return headers",
        "def test_reset_password_invalid_token(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"new_password\": \"changethis\", \"token\": \"invalid\"}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    response = r.json()\n\n    assert \"detail\" in response\n    assert r.status_code == 400\n    assert response[\"detail\"] == \"Invalid token\"",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "random_email": [
        "def create_random_user(db: Session) -> User:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    return user",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "random_lower_string": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def random_email() -> str:\n    return f\"{random_lower_string()}@{random_lower_string()}.com\"",
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "UserCreate": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "crud.create_user": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "crud.get_user_by_email": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_delete_user_current_super_user_error(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    super_user = crud.get_user_by_email(session=db, email=settings.FIRST_SUPERUSER)\n    assert super_user\n    user_id = super_user.id\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=superuser_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"Super users are not allowed to delete themselves\""
      ],
      "UserUpdate": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "Exception": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)"
      ],
      "crud.update_user": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)",
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "user_authentication_headers": [
        "def authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)"
      ],
      "random.choices": [
        "def random_lower_string() -> str:\n    return \"\".join(random.choices(string.ascii_lowercase, k=32))"
      ],
      "create_random_user": [
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)"
      ],
      "ItemCreate": [
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)"
      ],
      "crud.create_item": [
        "def create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)"
      ],
      "MagicMock": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "session_mock.configure_mock": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "patch": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_recovery_password(\n    client: TestClient, normal_user_token_headers: dict[str, str]\n) -> None:\n    with (\n        patch(\"app.core.config.settings.SMTP_HOST\", \"smtp.example.com\"),\n        patch(\"app.core.config.settings.SMTP_USER\", \"admin@example.com\"),\n    ):\n        email = \"test@example.com\"\n        r = client.post(\n            f\"{settings.API_V1_STR}/password-recovery/{email}\",\n            headers=normal_user_token_headers,\n        )\n        assert r.status_code == 200\n        assert r.json() == {\"message\": \"Password recovery email sent\"}",
        "def test_register_user_already_exists_error(client: TestClient) -> None:\n    with patch(\"app.core.config.settings.USERS_OPEN_REGISTRATION\", True):\n        password = random_lower_string()\n        full_name = random_lower_string()\n        data = {\n            \"email\": settings.FIRST_SUPERUSER,\n            \"password\": password,\n            \"full_name\": full_name,\n        }\n        r = client.post(\n            f\"{settings.API_V1_STR}/users/signup\",\n            json=data,\n        )\n        assert r.status_code == 400\n        assert (\n            r.json()[\"detail\"]\n            == \"The user with this email already exists in the system\"\n        )"
      ],
      "patch.object": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "init": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "select": [
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"",
        "def test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\""
      ],
      "hasattr": [
        "def test_create_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    assert user.email == email\n    assert hasattr(user, \"hashed_password\")"
      ],
      "crud.authenticate": [
        "def test_not_authenticate_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user = crud.authenticate(session=db, email=email, password=password)\n    assert user is None"
      ],
      "db.get": [
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "jsonable_encoder": [
        "def test_get_user(db: Session) -> None:\n    password = random_lower_string()\n    username = random_email()\n    user_in = UserCreate(email=username, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert jsonable_encoder(user) == jsonable_encoder(user_2)"
      ],
      "verify_password": [
        "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
      ],
      "generate_password_reset_token": [
        "def test_reset_password(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    token = generate_password_reset_token(email=settings.FIRST_SUPERUSER)\n    data = {\"new_password\": \"changethis\", \"token\": token}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    assert r.json() == {\"message\": \"Password updated successfully\"}"
      ],
      "response.json": [
        "def test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\""
      ],
      "create_random_item": [
        "def test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\""
      ],
      "client.get": [
        "def test_read_items(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    create_random_item(db)\n    create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert len(content[\"data\"]) >= 2",
        "def test_retrieve_users(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    crud.create_user(session=db, user_create=user_in2)\n\n    r = client.get(f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers)\n    all_users = r.json()\n\n    assert len(all_users[\"data\"]) > 1\n    assert \"count\" in all_users\n    for item in all_users[\"data\"]:\n        assert \"email\" in item"
      ],
      "len": [
        "def test_read_items(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    create_random_item(db)\n    create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert len(content[\"data\"]) >= 2",
        "def test_retrieve_users(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    crud.create_user(session=db, user_create=user_in2)\n\n    r = client.get(f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers)\n    all_users = r.json()\n\n    assert len(all_users[\"data\"]) > 1\n    assert \"count\" in all_users\n    for item in all_users[\"data\"]:\n        assert \"email\" in item"
      ],
      "client.put": [
        "def test_update_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    data = {\"title\": \"Updated title\", \"description\": \"Updated description\"}\n    response = client.put(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n        json=data,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\""
      ],
      "client.delete": [
        "def test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\"",
        "def test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\""
      ],
      "client.patch": [
        "def test_update_user_email_exists(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    user2 = crud.create_user(session=db, user_create=user_in2)\n\n    data = {\"email\": user2.email}\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 409\n    assert r.json()[\"detail\"] == \"User with this email already exists\""
      ]
    },
    "files": [],
    "readme": {
      "text": "# FastAPI Project - Backend\n\n## Requirements\n\n* [Docker](https://www.docker.com/).\n* [Poetry](https://python-poetry.org/) for Python package and environment management.\n\n## Local Development\n\n* Start the stack with Docker Compose:\n\n```bash\ndocker compose up -d\n```\n\n* Now you can open your browser and interact with these URLs:\n\nFrontend, built with Docker, with routes handled based on the path: http://localhost\n\nBackend, JSON based web API based on OpenAPI: http://localhost/api/\n\nAutomatic interactive documentation with Swagger UI (from the OpenAPI backend): http://localhost/docs\n\nAdminer, database web administration: http://localhost:8080\n\nTraefik UI, to see how the routes are being handled by the proxy: http://localhost:8090\n\n**Note**: The first time you start your stack, it might take a minute for it to be ready. While the backend waits for the database to be ready and configures everything. You can check the logs to monitor it.\n\nTo check the logs, run:\n\n```bash\ndocker compose logs\n```\n\nTo check the logs of a specific service, add the name of the service, e.g.:\n\n```bash\ndocker compose logs backend\n```\n\nIf your Docker is not running in `localhost` (the URLs above wouldn't work) you would need to use the IP or domain where your Docker is running.\n\n## Backend local development, additional details\n\n### General workflow\n\nBy default, the dependencies are managed with [Poetry](https://python-poetry.org/), go there and install it.\n\nFrom `./backend/` you can install all the dependencies with:\n\n```console\n$ poetry install\n```\n\nThen you can start a shell session with the new environment with:\n\n```console\n$ poetry shell\n```\n\nMake sure your editor is using the correct Python virtual environment.\n\nModify or add SQLModel models for data and SQL tables in `./backend/app/models.py`, API endpoints in `./backend/app/api/`, CRUD (Create, Read, Update, Delete) utils in `./backend/app/crud.py`.\n\n### VS Code\n\nThere are already configurations in place to run the backend through the VS Code debugger, so that you can use breakpoints, pause and explore variables, etc.\n\nThe setup is also already configured so you can run the tests through the VS Code Python tests tab.\n\n### Docker Compose Override\n\nDuring development, you can change Docker Compose settings that will only affect the local development environment in the file `docker-compose.override.yml`.\n\nThe changes to that file only affect the local development environment, not the production environment. So, you can add \"temporary\" changes that help the development workflow.\n\nFor example, the directory with the backend code is mounted as a Docker \"host volume\", mapping the code you change live to the directory inside the container. That allows you to test your changes right away, without having to build the Docker image again. It should only be done during development, for production, you should build the Docker image with a recent version of the backend code. But during development, it allows you to iterate very fast.\n\nThere is also a command override that runs `/start-reload.sh` (included in the base image) instead of the default `/start.sh` (also included in the base image). It starts a single server process (instead of multiple, as would be for production) and reloads the process whenever the code changes. Have in mind that if you have a syntax error and save the Python file, it will break and exit, and the container will stop. After that, you can restart the container by fixing the error and running again:\n\n```console\n$ docker compose up -d\n```\n\nThere is also a commented out `command` override, you can uncomment it and comment the default one. It makes the backend container run a process that does \"nothing\", but keeps the container alive. That allows you to get inside your running container and execute commands inside, for example a Python interpreter to test installed dependencies, or start the development server that reloads when it detects changes.\n\nTo get inside the container with a `bash` session you can start the stack with:\n\n```console\n$ docker compose up -d\n```\n\nand then `exec` inside the running container:\n\n```console\n$ docker compose exec backend bash\n```\n\nYou should see an output like:\n\n```console\nroot@7f2607af31c3:/app#\n```\n\nthat means that you are in a `bash` session inside your container, as a `root` user, under the `/app` directory, this directory has another directory called \"app\" inside, that's where your code lives inside the container: `/app/app`.\n\nThere you can use the script `/start-reload.sh` to run the debug live reloading server. You can run that script from inside the container with:\n\n```console\n$ bash /start-reload.sh\n```\n\n...it will look like:\n\n```console\nroot@7f2607af31c3:/app# bash /start-reload.sh\n```\n\nand then hit enter. That runs the live reloading server that auto reloads when it detects code changes.\n\nNevertheless, if it doesn't detect a change but a syntax error, it will just stop with an error. But as the container is still alive and you are in a Bash session, you can quickly restart it after fixing the error, running the same command (\"up arrow\" and \"Enter\").\n\n...this previous detail is what makes it useful to have the container alive doing nothing and then, in a Bash session, make it run the live reload server.\n\n### Backend tests\n\nTo test the backend run:\n\n```console\n$ bash ./scripts/test.sh\n```\n\nThe tests run with Pytest, modify and add tests to `./backend/app/tests/`.\n\nIf you use GitHub Actions the tests will run automatically.\n\n#### Test running stack\n\nIf your stack is already up and you just want to run the tests, you can use:\n\n```bash\ndocker compose exec backend bash /app/tests-start.sh\n```\n\nThat `/app/tests-start.sh` script just calls `pytest` after making sure that the rest of the stack is running. If you need to pass extra arguments to `pytest`, you can pass them to that command and they will be forwarded.\n\nFor example, to stop on first error:\n\n```bash\ndocker compose exec backend bash /app/tests-start.sh -x\n```\n\n#### Test Coverage\n\nWhen the tests are run, a file `htmlcov/index.html` is generated, you can open it in your browser to see the coverage of the tests.\n\n### Migrations\n\nAs during local development your app directory is mounted as a volume inside the container, you can also run the migrations with `alembic` commands inside the container and the migration code will be in your app directory (instead of being only inside the container). So you can add it to your git repository.\n\nMake sure you create a \"revision\" of your models and that you \"upgrade\" your database with that revision every time you change them. As this is what will update the tables in your database. Otherwise, your application will have errors.\n\n* Start an interactive session in the backend container:\n\n```console\n$ docker compose exec backend bash\n```\n\n* Alembic is already configured to import your SQLModel models from `./backend/app/models.py`.\n\n* After changing a model (for example, adding a column), inside the container, create a revision, e.g.:\n\n```console\n$ alembic revision --autogenerate -m \"Add column last_name to User model\"\n```\n\n* Commit to the git repository the files generated in the alembic directory.\n\n* After creating the revision, run the migration in the database (this is what will actually change the database):\n\n```console\n$ alembic upgrade head\n```\n\nIf you don't want to use migrations at all, uncomment the lines in the file at `./backend/app/core/db.py` that end in:\n\n```python\nSQLModel.metadata.create_all(engine)\n```\n\nand comment the line in the file `prestart.sh` that contains:\n\n```console\n$ alembic upgrade head\n```\n\nIf you don't want to start with the default models and want to remove them / modify them, from the beginning, without having any previous revision, you can remove the revision files (`.py` Python files) under `./backend/app/alembic/versions/`. And then create a first migration as described above.\n\n\nGeneric single-database configuration.\n\n\n",
      "summary": "# FastAPI Project - Backend\n\nThis project is a backend developed using FastAPI. It requires Docker and Poetry for Python package and environment management.\n\n## Key Features\n\n- Frontend built with Docker, with routes handled based on the path.\n- Backend, JSON based web API based on OpenAPI.\n- Automatic interactive documentation with Swagger UI.\n- Adminer for database web administration.\n- Traefik UI to monitor how routes are handled by the proxy.\n\n## Local Development\n\nTo start the stack, use Docker Compose with the command `docker compose up -d`. The first time you start your stack, it might take a minute for it to be ready. You can check the logs to monitor it using `docker compose logs`.\n\n## Backend Local Development\n\nDependencies are managed with Poetry. You can install all the dependencies from `./backend/` using `poetry install` and start a shell session with the new environment using `poetry shell`.\n\nYou can modify or add SQLModel models for data and SQL tables in `./backend/app/models.py`, API endpoints in `./backend/app/api/`, CRUD utils in `./backend/app/crud.py`.\n\n## VS Code\n\nThe project is configured to run the backend through the VS Code debugger and run the tests through the VS Code Python tests tab.\n\n## Docker Compose Override\n\nDuring development, you can change Docker Compose settings that will only affect the local development environment in the file `docker-compose.override.yml`.\n\n## Backend Tests\n\nTo test the backend, run `bash ./scripts/test.sh`. The tests run with Pytest, modify and add tests to `./backend/app/tests/`.\n\n## Migrations\n\nAfter changing a model, create a revision and run the migration in the database. Alembic is already configured to import your SQLModel models from `./backend/app/models.py`.\n\n## Contribution\n\nThe project allows for contributions. However, contributors are expected to follow the outlined workflow and use the provided configurations for local development, testing, and migrations."
    },
    "functions": [
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "This Python function `get_user_by_email` takes in a SQLAlchemy session and an email as arguments, and using the session and the ORM (Object-Relational Mapping) tool called SQLAlchemy, it retrieves a single user from the database by matching their email with the given email. The function returns either the found user or `None` if no user is found. The returned user object is assigned to a variable named `session_user` and then passed back as the function's return value.",
        "code_with_comments": "\nThe system parses the function to identify its purpose, parameters, and return value. Based on this analysis, it generates a commented version of the function as follows:\n```python\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    \"\"\"\n    Returns the user with the given email address, or None if no such user exists.\n    \n    Parameters:\n        session (Session): The SQLAlchemy session to use for querying the database.\n        email (str): The email address of the user to retrieve.\n    \n    Return value:\n        User | None: The retrieved user, or None if no such user exists.\n    \"\"\"\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n```\nThis commented version of the function provides more information about its purpose, parameters, and return value than the original code. It also includes a docstring that explains the function's behavior in detail.",
        "test": " "
      },
      {
        "name": "create_user",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/api/routes/users.py",
        "code": "def create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    return user",
        "summary": "The `create_user` function in Python creates a new user when called. It takes two arguments: `session`, which is an instance of the SQLAlchemy Session class used for database transactions, and `user_in`, which is an object containing information about the new user being created. First, it checks if a user already exists in the system with the same email address using another function called `crud.get_user_by_email`. If such a user is found, the function raises an HTTPException with a 400 status code and a detailed error message. If the new user's email address is valid and the `emails_enabled` setting is true, the function generates a new account email using another function called `generate_new_account_email`. This email contains information about the username, password, and email address of the new user. The email is then sent to the user's email address using a function called `send_email`. After all the necessary checks and preparations are completed, the new user is created using another function called `crud.create_user`. The newly created user is then returned from the `create_user` function.",
        "code_with_comments": "\nHere is the commented version of the function:\n```\ndef create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \n    Parameters\n    ----------\n    session : SessionDep\n        The current session object.\n    user_in : UserCreate\n        The input user data.\n    \n    Returns\n    -------\n    Any\n        The created user object.\n    \"\"\"\n    # Get the user by email\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    \n    # Check if the user already exists\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n    \n    # Create the new user\n    user = crud.create_user(session=session, user_create=user_in)\n    \n    # Send an email to the user's email address if enabled\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    \n    return user\n```",
        "test": " "
      },
      {
        "name": "generate_new_account_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_new_account_email(\n    email_to: str, username: str, password: str\n) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - New account for user {username}\"\n    html_content = render_email_template(\n        template_name=\"new_account.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": settings.server_host,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
        "summary": "This Python function takes in three arguments: `email_to`, `username`, and `password`. It generates a new account email with the given user information and returns an object called `EmailData` containing the email content and subject. The project name is retrieved from a setting, and a custom HTML email template is rendered using Django's `render_email_template` function. The resulting email will be sent to the specified email address (`email_to`) with the given username, password, and project name as context for the email template.",
        "code_with_comments": "\nThe system will generate a commented version of the function based on its analysis. Here is an example of what the commented code might look like:\n```\n# This function generates a new account email for a user with the given username and password.\ndef generate_new_account_email(\n    # The email address to send the email to.\n    email_to: str, \n    \n    # The username of the new account.\n    username: str, \n    \n    # The password for the new account.\n    password: str\n) -> EmailData:\n    # Load project settings from environment variables.\n    settings = Settings()\n    \n    # Set the subject line of the email.\n    subject = f\"{settings.PROJECT_NAME} - New account for user {username}\"\n    \n    # Render the email template with the given context.\n    html_content = render_email_template(\n        template_name=\"new_account.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": settings.server_host,\n        },\n    )\n    \n    # Return the EmailData object with the rendered content and subject line.\n    return EmailData(html_content=html_content, subject=subject)\n```",
        "test": " "
      },
      {
        "name": "send_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")",
        "summary": "The `send_email` function in Python is used to send an email with a customizable subject, HTML content, and recipient email address. The function first checks if the necessary configuration for email variables is provided and raises an assertion error if not. Then, it creates a new email message using the `emails.Message()` class from the standard library's `email.mime.text` module. The sender name and email address are specified in the configuration settings.\n\nThe function also accepts optional arguments for the SMTP server host, port, TLS or SSL encryption method, and authentication credentials. The message is then sent using the `send()` method of the `Message()` class with the specified recipient email address and SMTP connection options. The function returns `None` to indicate successful completion.\n\nThe function also logs the result of sending the email for future reference or debugging purposes.",
        "code_with_comments": "\nThe system parses the function to identify its purpose, parameters, and return value. It then generates a commented version of the function based on this analysis. The following is the commented code for the given Python function:\n```python\n# Send an email with the specified subject, HTML content, and recipient.\ndef send_email(\n    *,  # This is called a \"keyword-only argument\" in Python. It means that only positional arguments can be passed after this one.\n    email_to: str,  # Recipient of the email (must be a string)\n    subject: str = \"\",  # Subject of the email (defaults to an empty string)\n    html_content: str = \"\",  # HTML content of the email (defaults to an empty string)\n):\n    assert settings.emails_enabled, \"no provided configuration for email variables\"  # Ensure that emails are enabled before sending them.\n    message = emails.Message(  # Create a new email message with the specified subject and HTML content.\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}  # Set the SMTP host and port based on the settings.\n    if settings.SMTP_TLS:  # If TLS is enabled, set the \"tls\" option to True.\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:  # Otherwise, if SSL is enabled, set the \"ssl\" option to True.\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:  # If a user has been provided, add it to the SMTP options.\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:  # Similarly, if a password has been provided, add it to the SMTP options.\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)  # Send the email with the specified recipient and SMTP options.\n    logging.info(f\"send email result: {response}\")  # Log the send email result.\n```",
        "test": " "
      },
      {
        "name": "get_password_hash",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)",
        "summary": "This Python function, named `get_password_hash`, takes a string argument `password` and returns the hashed value of that password using the `pwd_context` module in Python's standard library. The function is called `get_password_hash` because it retrieves a hash value for a given password, which can be used for secure storage and comparison. The return type is a string, indicating that the hashed value will be provided back to the user.",
        "code_with_comments": "[PYTHON]\ndef get_password_hash(password: str) -> str:\n    \"\"\"\n    Generates a password hash using the given password string.\n\n    Args:\n        password (str): The password to be hashed.\n\n    Returns:\n        str: The generated password hash.\n    \"\"\"\n    return pwd_context.hash(password)\n[/PYTHON]\n[TESTS]\n# Test case 1:\nassert get_password_hash(\"abc123\") == \"hashed_abc123\"\n# Test case 2:\nassert get_password_hash(\"password1\") == \"hashed_password1\"\n# Test case 3:\nassert get_password_hash(\"12345678\") == \"hashed_12345678\"\n[/TESTS]\n",
        "test": " "
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "The `get_user_by_email` function is a Python method that retrieves a user with the specified email address from a database using the SQLAlchemy ORM (Object-Relational Mapping) library. It takes two arguments: `session`, which is a session object used to manage connections to the database, and `email`, which is the email address of the user being searched for. The function returns the user found with the matching email address or `None` if no user is found. This method is marked as a coroutine using the `async def` syntax, but since we're providing an actual `Session` argument and not an async context manager, it's actually invoked synchronously.",
        "code_with_comments": "\nHere is the commented version of the function based on the analysis:\n```\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    \"\"\"\n    Retrieves a user by their email address.\n    \n    Parameters:\n        session (Session): The SQLAlchemy session object used to query the database.\n        email (str): The email address of the user to retrieve.\n    \n    Returns:\n        User | None: The retrieved user, or None if no user with the specified email was found.\n    \"\"\"\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n```",
        "test": " "
      },
      {
        "name": "create_user",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/api/routes/users.py",
        "code": "def create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    return user",
        "summary": "The Python function `create_user` creates a new user. It first checks if a user already exists with the same email using the `crud.get_user_by_email` function. If such a user exists, an error is raised. Otherwise, a new user is created using the `crud.create_user` function and passed the user input (stored in the `user_in` argument). Additionally, if email notifications are enabled and an email address was provided during user creation, an email is generated using the `generate_new_account_email` function and sent using the `send_email` function. The finished user object is then returned from the function.",
        "code_with_comments": "\nThe input function is:\n```\ndef create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    return user\n```\nThe output of the system will be:\n```\n# create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n#     \"\"\"\n#     Create new user.\n#     \"\"\"\n#     user = crud.get_user_by_email(session=session, email=user_in.email)\n#     if user:\n#         raise HTTPException(\n#             status_code=400,\n#             detail=\"The user with this email already exists in the system.\",\n#         )\n# \n#     user = crud.create_user(session=session, user_create=user_in)\n#     if settings.emails_enabled and user_in.email:\n#         email_data = generate_new_account_email(\n#             email_to=user_in.email, username=user_in.email, password=user_in.password\n#         )\n#         send_email(\n#             email_to=user_in.email,\n#             subject=email_data.subject,\n#             html_content=email_data.html_content,\n#         )\n#     return user\n```",
        "test": " "
      },
      {
        "name": "get_password_hash",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)",
        "summary": "This Python function, named `get_password_hash`, takes a password as an argument of type string and returns its hash using the `pwd_context` module. The `pwd_context` is likely referring to the `Crypt` library in Python, which provides secure password storage methods. This function can be used for securely storing passwords in databases or files instead of plain text versions.",
        "code_with_comments": "\nThe system will parse the function and generate a commented version of it based on its purpose, parameters, and return value. Here's an example of what the commented code might look like:\n```\n# Function to get password hash\ndef get_password_hash(password: str) -> str:\n    \"\"\"\n    Generates a password hash using the pwd_context module.\n\n    :param password: The input password as a string.\n    :return: A generated password hash as a string.\n    \"\"\"\n    return pwd_context.hash(password)\n```\nIn this example, the system has identified that the function takes a single parameter `password` of type `str`, and returns a value of type `str`. The system has also added a docstring to explain the purpose of the function and provide information about its parameters and return value.",
        "test": " "
      },
      {
        "name": "generate_test_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_test_email(email_to: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Test email\"\n    html_content = render_email_template(\n        template_name=\"test_email.html\",\n        context={\"project_name\": settings.PROJECT_NAME, \"email\": email_to},\n    )\n    return EmailData(html_content=html_content, subject=subject)",
        "summary": "The function `generate_test_email` takes a string `email_to` as input and returns an instance of `EmailData`. The function sets the project name from the `settings.PROJECT_NAME` variable, creates a subject for the email with this project name and \"Test email\" appended, and generates HTML content using the `render_email_template` function with the template named `test_email.html` and a context containing the project name and email address to be replaced in the template. The `EmailData` object is then returned with both the generated HTML content and subject. In summary, this function generates an email with a test message containing the project name and sends it to the specified email address using the provided settings.",
        "code_with_comments": "\nHere is a commented version of the `generate_test_email` function:\n```\ndef generate_test_email(email_to: str) -> EmailData:\n    \"\"\"\n    Generate a test email using the provided recipient email address.\n\n    Parameters:\n        email_to (str): The recipient's email address.\n\n    Returns:\n        EmailData: An object containing the HTML content and subject of the test email.\n    \"\"\"\n    project_name = settings.PROJECT_NAME  # Get the current project name from settings\n    subject = f\"{project_name} - Test email\"  # Create a subject line for the test email\n    html_content = render_email_template(  # Render an HTML template with the project name and recipient email address\n        template_name=\"test_email.html\",\n        context={\"project_name\": settings.PROJECT_NAME, \"email\": email_to},\n    )\n    return EmailData(html_content=html_content, subject=subject)  # Return an object containing the HTML content and subject of the test email\n```\nIn this comment, we have added a brief description of what the function does, as well as any parameters or return values that are relevant to the function's purpose. We have also used natural language to explain the code, making it easier for other developers to understand the function's intent and usage.",
        "test": " "
      },
      {
        "name": "send_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")",
        "summary": "This Python function, named `send_email`, sends an email with a customizable subject, HTML content, and recipient address (specified by the `email_to` parameter). The configuration for email variables is required (as indicated by the `settings.emails_enabled` assertion), and the email's sender name and email address can be set through the `settings` object. SMTP settings such as TLS, SSL, username, and password can also be specified using the `settings` object. The function returns `None`, and its execution is logged to the console for debugging purposes.",
        "code_with_comments": "\nHere's the commented version of the function based on the analysis:\n```\ndef send_email(\n    *,  # This parameter is used to pass any number of positional arguments\n    email_to: str,  # The recipient of the email\n    subject: str = \"\",  # The subject line of the email (defaults to an empty string)\n    html_content: str = \"\",  # The HTML content of the email (defaults to an empty string)\n) -> None:\n    \"\"\"Send an email using the configured SMTP settings.\n\n    Args:\n        email_to (str): The recipient of the email\n        subject (str, optional): The subject line of the email. Defaults to \"\".\n        html_content (str, optional): The HTML content of the email. Defaults to \"\".\n\n    Returns:\n        None: No return value is returned\n\n    Raises:\n        AssertionError: If the settings for email variables are not provided\n\n    Examples:\n        >>> send_email(email_to=\"john.doe@example.com\", subject=\"Test Subject\", html_content=\"<p>Hello, world!</p>\")\n        send email result: {'ok': True}\n```\nThe comments explain the purpose of the function, the parameters and their default values, the return value, and any potential exceptions that may be raised. The examples section provides a usage example for the function.",
        "test": " "
      },
      {
        "name": "authenticate",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def authenticate(*, session: Session, email: str, password: str) -> User | None:\n    db_user = get_user_by_email(session=session, email=email)\n    if not db_user:\n        return None\n    if not verify_password(password, db_user.hashed_password):\n        return None\n    return db_user",
        "summary": "The `authenticate` function in Python takes arguments `session`, `email`, and `password`. It first retrieves the user with the provided email from a database using the `get_user_by_email` function. If the user is not found, the function returns `None`. Otherwise, it checks whether the provided password matches the hashed password of the user using the `verify_password` function. If the passwords do not match, the function returns `None`. If both conditions are met, the function returns the authenticated user object. Overall, this function is used to authenticate a user's login credentials against a database.",
        "code_with_comments": "Here is the commented version of the function based on the analysis:\n```\ndef authenticate(*, session: Session, email: str, password: str) -> User | None:\n    \"\"\"\n    Authenticates a user with their email and password. If successful, returns the User object, otherwise returns None.\n    \n    Parameters:\n        * session (Session): The database session used for querying the user data.\n        * email (str): The user's email address.\n        * password (str): The user's password.\n    \n    Returns:\n        User | None: The authenticated user object, or None if authentication failed.\n    \"\"\"\n    db_user = get_user_by_email(session=session, email=email)\n    if not db_user:\n        return None\n    if not verify_password(password, db_user.hashed_password):\n        return None\n    return db_user\n```",
        "test": " "
      },
      {
        "name": "create_access_token",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def create_access_token(subject: str | Any, expires_delta: timedelta) -> str:\n    expire = datetime.utcnow() + expires_delta\n    to_encode = {\"exp\": expire, \"sub\": str(subject)}\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt",
        "summary": "The function `create_access_token` in Python takes two arguments - `subject`, which can be a string or any other type, and `expires_delta`, which is a time delta. It creates an access token by encoding a dictionary containing the `exp` (expiration time) and `sub` (subject) fields using the `jwt.encode()` function with the provided secret key and algorithm. The expiration time is calculated as the current UTC time plus the specified time delta, and the subject is converted to a string before being included in the dictionary. The encoded access token is then returned by the function. In summary, this function generates an access token with an expiration time and includes specific information about the request's subject.",
        "code_with_comments": "  Here is a commented version of the `create_access_token` function based on the analysis:\n```\ndef create_access_token(subject: str | Any, expires_delta: timedelta) -> str:\n    \"\"\"\n    Generates an access token for the given subject and expiration delta.\n\n    Parameters:\n        subject (str | Any): The subject of the access token. Can be a string or any object.\n        expires_delta (timedelta): The amount of time the access token is valid for.\n\n    Returns:\n        str: The encoded JWT access token.\n    \"\"\"\n    # Get the current UTC datetime\n    now = datetime.utcnow()\n\n    # Calculate the expiration date and time\n    expire = now + expires_delta\n\n    # Create a dictionary with the \"exp\" and \"sub\" claims\n    to_encode = {\n        \"exp\": expire,\n        \"sub\": str(subject)\n    }\n\n    # Encode the JWT using the SECRET_KEY and ALGORITHM settings\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n\n    # Return the encoded JWT access token\n    return encoded_jwt\n```",
        "test": " "
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "The function `get_user_by_email` is a method that retrieves a user with the provided email address using the SQLAlchemy library's session object. It takes two parameters, `session` and `email`, where `session` is an instance of the SQLAlchemy Session class, and `email` is the unique identifier for the user in question. The function uses a SELECT statement with a WHERE clause to filter the User table for the user with the specified email address. The resultant row from the query is returned as either a User object or None if no matching user is found.",
        "code_with_comments": "\nThe system will parse the function to identify its purpose, parameters, and return value. Based on this analysis, it will generate a commented version of the function as follows:\n```\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    \"\"\"\n    Retrieves a user by their email address.\n    \n    :param session: The SQLAlchemy session to use for the query.\n    :type session: sqlalchemy.orm.Session\n    :param email: The email address of the user to retrieve.\n    :type email: str\n    :return: The retrieved user, or None if no user was found with the given email.\n    :rtype: User | None\n    \"\"\"\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n```\nThis commented version of the function provides a description of its purpose, lists each of its parameters and their types, and specifies the expected return value. It also includes a colon (`:`) after each parameter name to indicate that it is a type hint for that parameter.",
        "test": " "
      },
      {
        "name": "verify_password",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)",
        "summary": "This Python function named `verify_password` takes two arguments, a plain text password `plain_password` and a previously hashed password `hashed_password`. It then calls the `verify()` method of an instance called `pwd_context`, which is assumed to have been initialized elsewhere. This method returns a boolean value indicating whether the plain text password matches the hashed password, and the function returns this value as well. In summary, this function checks if a given plain text password matches the hashed version of that password.",
        "code_with_comments": "  ```\n# Verify password\n#\n# This function takes in two parameters:\n# - plain_password: the plain text password to be verified\n# - hashed_password: the previously hashed password to compare with\n#\n# It returns a boolean value indicating whether the provided plain password matches the previously hashed password\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    # Verify the password by comparing it with the previously hashed password\n    return pwd_context.verify(plain_password, hashed_password)\n```",
        "test": [
          "def test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)"
        ]
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "This Python function `get_user_by_email` is a method that retrieves a user by their email address from a database using the SQLAlchemy library. The function takes two arguments, `session` which represents the current database session, and `email`, the unique identifier for the user's email address. \n\nThe function uses the built-in SQLAlchemy method `select` to create a statement that selects all columns from the `User` table where the value of the `email` column matches the provided `email` argument. The statement is executed using the `exec` method, and the resulting data (if any) is returned as the `session_user` variable.\n\nFinally, the function returns either the retrieved user object or `None` if no user was found in the database for the specified email address.",
        "code_with_comments": "  ```\n# Function to get a user by their email address\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    # SQL statement to select the user based on their email address\n    statement = select(User).where(User.email == email)\n    \n    # Execute the SQL statement and fetch the first result\n    session_user = session.exec(statement).first()\n    \n    # Return the user object or None if no user was found\n    return session_user\n```",
        "test": " "
      },
      {
        "name": "generate_password_reset_token",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_password_reset_token(email: str) -> str:\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt",
        "summary": "This Python function generates a password reset token for the provided email address. It creates an expiration time based on the number of hours specified in a settings variable, calculates the current UTC time, adds the delta to get the expiration time, and then uses the JWT (JSON Web Tokens) library to encode a payload containing the expiration time, creation time, and email address into a string token. The function returns the generated token.",
        "code_with_comments": "\nThe system will generate a commented version of the function based on its analysis:\n```\ndef generate_password_reset_token(email: str) -> str:\n    \"\"\"\n    Generates a password reset token for the specified email address.\n    \n    Parameters:\n        email (str): The email address to generate the reset token for.\n    \n    Returns:\n        encoded_jwt (str): The generated reset token, which is an encrypted JSON web token.\n    \"\"\"\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt\n```",
        "test": [
          "def test_reset_password(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    token = generate_password_reset_token(email=settings.FIRST_SUPERUSER)\n    data = {\"new_password\": \"changethis\", \"token\": token}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    assert r.json() == {\"message\": \"Password updated successfully\"}"
        ]
      },
      {
        "name": "generate_reset_password_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
        "summary": "The Python function `generate_reset_password_email` takes three arguments: `email_to`, `email`, and `token`. It then retrieves the project name from a setting called `PROJECT_NAME`, generates an email subject with the user's email and project name, creates a link with the token for resetting password, renders an email template named \"reset_password.html\" using Django's `render_email_template` function, and returns an object of type `EmailData` containing the HTML content of the email and subject. This function is likely used to send an email to a user requesting a password reset with a link to click that will take them to a page where they can enter a new password. The function's purpose is to generate the email content automatically based on the provided arguments, making it easier to reuse this functionality in other parts of the application.",
        "code_with_comments": "The system will generate a commented version of the function based on its analysis. The generated code will be similar to the following:\n```\ndef generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:  # Purpose of this function is to generate an email for password recovery.\n    project_name = settings.PROJECT_NAME  # Name of the project from where the email is being sent.\n    subject = f\"{project_name} - Password recovery for user {email}\"  # Subject of the email, includes the name of the project and the username of the person who requested the password reset.\n    link = f\"{settings.server_host}/reset-password?token={token}\"  # URL to which the email link will redirect to.\n    html_content = render_email_template(  # Function that renders the HTML template for the email content.\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)  # Return value of the function, which includes the HTML content and the subject of the email.\n```\nIn this example, the system has identified the purpose of the function as generating an email for password recovery, and has generated a commented version of the code based on this analysis. The comments explain each line of code in detail, making it easier to understand the function's intended behavior.",
        "test": " "
      },
      {
        "name": "send_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")",
        "summary": "The `send_email` function in Python is used to send an email with a customizable subject and optional HTML content to a specified recipient, defined by the `email_to` parameter. If no subject or HTML content are provided, they will be empty strings by default. The function first checks if configuration settings for email variables are provided and raises an assertion error if not. It then creates a new message object using the `emails.Message()` class from an external library called \"emails\". The SMTP (Simple Mail Transfer Protocol) options, such as host, port, TLS/SSL encryption, user, and password, are defined in configuration settings. After creating the message object, it is sent to the recipient using the `send()` method of the message object, with the necessary options passed as arguments. The result of the email sending process is logged for information purposes. Overall, this function provides a customizable way to send emails from within Python code with different levels of configuration settings provided.",
        "code_with_comments": "  Sure! Here is the commented version of the `send_email` function based on the analysis:\n```\ndef send_email(\n    # Sends an email to the specified recipient with the given subject and content.\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    # Assert that email settings are enabled, otherwise throw an error.\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    \n    # Create a new email message with the specified subject and content.\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    \n    # Define the SMTP options for sending the email.\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    \n    # Check if TLS or SSL is enabled and add it to the SMTP options if necessary.\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    \n    # Check if a username or password is specified and add it to the SMTP options if necessary.\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    \n    # Send the email using the specified SMTP options.\n    response = message.send(to=email_to, smtp=smtp_options)\n    \n    # Log the result of the email send operation.\n    logging.info(f\"send email result: {response}\")\n```",
        "test": " "
      },
      {
        "name": "verify_password_reset_token",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def verify_password_reset_token(token: str) -> str | None:\n    try:\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        return str(decoded_token[\"sub\"])\n    except JWTError:\n        return None",
        "summary": "This Python function `verify_password_reset_token` takes a string `token` as input and returns either a string or `None`. It first attempts to decode the `token` using the `jwt.decode()` function with the specified secret key and algorithm (\"HS256\"). If the decoding is successful, it extracts the value of the \"sub\" (subject) field from the decoded token and returns it as a string. If the decoding fails due to an error (such as an incorrect token or expiration), `None` is returned instead.",
        "code_with_comments": "\nThe system will generate the following commented version of the function:\n```\ndef verify_password_reset_token(token: str) -> str | None:\n    \"\"\"\n    Verifies a password reset token and returns the user ID if valid, or None otherwise.\n    \n    Parameters:\n        token (str): The password reset token to be verified.\n    \n    Returns:\n        str | None: The user ID if the token is valid, or None if it's invalid or has expired.\n    \"\"\"\n    try:\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        return str(decoded_token[\"sub\"])\n    except JWTError:\n        return None\n```",
        "test": " "
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "This Python function is called `get_user_by_email` and takes two arguments, a SQLAlchemy session (`session`) and the user's email address (`email`). It returns either the User object from the database corresponding to the given email or `None` if no such User exists. The function creates a SELECT statement using SQLAlchemy's `select()` function, filters the result set to only include Users with the specified email address using the `where()` function, executes the query within the session object using `exec()`, and returns the first result returned by the query as the session_user variable.",
        "code_with_comments": "\nThe system parses the function to identify its purpose, parameters, and return value. Based on this analysis, it generates a commented version of the function as follows:\n```\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    \"\"\"\n    Returns a user object by email address.\n\n    Args:\n        * session: A SQLAlchemy session object used to query the database.\n        * email: The email address of the user to retrieve.\n\n    Returns:\n        A User object if found, or None if not found.\n    \"\"\"\n\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n```",
        "test": " "
      },
      {
        "name": "get_password_hash",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/core/security.py",
        "code": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)",
        "summary": "The given Python function, named `get_password_hash`, takes a single argument `password` of type string and returns a string representing the hash value of the password using the `pwd_context` module for password storage. This hashed value can be used to securely store the password in a database or other system without storing the plain text password itself, improving security.",
        "code_with_comments": "  ```\n# Get password hash\n#\n# Purpose: Generates a hash of the given password using the pwd_context context.\n#\n# Parameters:\n#   password (str): The password to be hashed.\n#\n# Return value:\n#   str: The generated hash of the password.\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n```",
        "test": " "
      },
      {
        "name": "get_user_by_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/crud.py",
        "code": "def get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user",
        "summary": "This Python function, named `get_user_by_email`, takes two arguments: a database session (`session`) and an email address (`email`). It retrieves a user record from the database by selecting (`select`) the `User` object where the `email` matches the input value (`where(User.email == email)`). The result is returned as either the selected `User` object or `None` if no match was found (`session.exec(statement).first()`). This function can be used to efficiently and securely retrieve a user's details based on their email address, which may be useful for various operations such as login, password reset, or account management.",
        "code_with_comments": "\nThe system will generate a commented version of the function as follows:\n```\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    # Select a user from the database based on their email address\n    statement = select(User).where(User.email == email)\n\n    # Execute the query and retrieve the first result\n    session_user = session.exec(statement).first()\n\n    return session_user\n```",
        "test": " "
      },
      {
        "name": "generate_password_reset_token",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_password_reset_token(email: str) -> str:\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt",
        "summary": "The provided Python function `generate_password_reset_token` takes an email as input and returns a string representing a JWT (JSON Web Token) used for password reset operations. The function creates a token that expires after a specified number of hours (determined by the `settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS` variable), with a payload containing the email address and an expiration timestamp generated from the current UTC time and the specified time delta. The JWT is encoded using the `jwt.encode()` function, which requires the secret key (stored in the `settings.SECRET_KEY`) and the HS256 encryption algorithm.",
        "code_with_comments": "\nHere's the commented version of the function:\n```\ndef generate_password_reset_token(email: str) -> str:\n    \"\"\"\n    Generates a password reset token for the specified email address.\n\n    :param email: The email address to generate the token for.\n    :return: A signed, JSON Web Token (JWT) that contains the expiration date and the email address.\n    \"\"\"\n    # Calculate the delta between now and the expiration date\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    # Encode the JWT with the specified algorithm\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt\n```",
        "test": [
          "def test_reset_password(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    token = generate_password_reset_token(email=settings.FIRST_SUPERUSER)\n    data = {\"new_password\": \"changethis\", \"token\": token}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    assert r.json() == {\"message\": \"Password updated successfully\"}"
        ]
      },
      {
        "name": "generate_reset_password_email",
        "path": "/Users/williambrach/Developer/hackkosice/hk-2024/full-stack-fastapi-template/backend/app/utils.py",
        "code": "def generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)",
        "summary": "This Python function named `generate_reset_password_email` takes three arguments: `email_to`, `email`, and `token`. It then uses the `settings` object to retrieve the project name and server host, and creates a subject for the email with this information. The link to reset the password is generated using the `token` parameter and the server host. \n\nNext, the function renders an email template called \"reset_password.html\" using the `render_email_template` helper method. It passes the project name, username (email), email address to send the email to, the number of valid hours for the token, and the generated link as context to the template. \n\nFinally, the function returns an object called `EmailData` containing the HTML content and subject of the email that was just created. This object can be used by an email sending library or framework to actually send the password reset email. Overall, this function generates a password reset email with a customizable subject, link, and template for sending out via email.",
        "code_with_comments": "\nThe system generates the following commented version of the function:\n```\ndef generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    # Purpose: Generate an email that allows a user to reset their password.\n\n    # Parameters:\n    # - email_to (str): The email address of the user who is requesting the reset.\n    # - email (str): The email address of the user whose password needs to be reset.\n    # - token (str): A unique token used for password recovery.\n\n    # Return value: An instance of EmailData that contains the email content and subject line.\n\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)\n```",
        "test": " "
      }
    ],
    "business_stories": [
      {
        "name": "users.py",
        "story": [
          {
            "route": "/",
            "functions": [
              "get_user_by_email",
              "create_user",
              "generate_new_account_email",
              "send_email",
              "get_password_hash"
            ],
            "order_summary": [
              {
                "group_name": "User Management",
                "items": [
                  {
                    "name": "get_user_by_email"
                  },
                  {
                    "name": "create_user"
                  }
                ]
              },
              {
                "group_name": "Email Management",
                "items": [
                  {
                    "name": "generate_new_account_email"
                  },
                  {
                    "name": "send_email"
                  }
                ]
              },
              {
                "group_name": "Security",
                "items": [
                  {
                    "name": "get_password_hash"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure user management system for a Python-based application. The system includes functionalities such as user creation, user retrieval, password hashing, and email notifications. \n\n1. User Retrieval: The `get_user_by_email` function retrieves a user from the database using their email address. This function is crucial for operations like user login, password reset, and account management. \n\n2. User Creation: The `create_user` function creates a new user in the system. It checks if a user with the same email already exists to avoid duplication. If email notifications are enabled, it sends an email to the new user with their account details.\n\n3. Password Hashing: The `get_password_hash` function hashes user passwords for secure storage. Storing hashed passwords instead of plain text enhances the security of user data.\n\n4. Email Notifications: The `generate_new_account_email` function generates an email for new users with their account details. The `send_email` function sends this email to the user. Email notifications improve user experience and provide users with necessary account information.\n\nThe implementation of these functions will enhance the security and efficiency of the user management system. It will also improve the user experience by providing timely email notifications. The system can be further improved by adding more functionalities like user role management, user activity tracking, and more."
          },
          {
            "route": "/me",
            "functions": [],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their supply chain, which has led to increased operational costs and decreased customer satisfaction due to delayed deliveries. \n\nThe company has been using traditional methods for supply chain management, which lack real-time tracking and data analysis capabilities. The management is considering implementing a digital transformation strategy to improve their supply chain operations. However, they are unsure about the potential benefits and return on investment.\n\nBusiness Case:\n\nTitle: Digital Transformation of Supply Chain Operations at XYZ Corp\n\n1. Situation Analysis:\n   XYZ Corp is facing challenges in managing its supply chain, leading to increased operational costs and decreased customer satisfaction. The current traditional methods lack real-time tracking and data analysis capabilities.\n\n2. Proposed Solution:\n   Implement a digital transformation strategy that includes the adoption of a modern supply chain management system. This system would provide real-time tracking, predictive analytics, and data-driven decision-making capabilities.\n\n3. Benefits:\n   - Improved operational efficiency: The new system would streamline supply chain processes, reducing operational costs.\n   - Enhanced customer satisfaction: With improved delivery times, customer satisfaction would increase, potentially leading to higher sales.\n   - Data-driven decision making: The system would provide valuable insights into the supply chain, enabling the company to make informed decisions.\n\n4. Costs:\n   The costs of this project would include the purchase and implementation of the new system, training for staff, and ongoing maintenance and updates.\n\n5. Return on Investment:\n   The return on investment would be calculated by comparing the cost savings and increased revenue from improved customer satisfaction against the costs of the project.\n\n6. Risks and Mitigation Strategies:\n   Risks include potential resistance from staff, technical issues during implementation, and the new system not delivering the expected benefits. These risks can be mitigated through proper change management, technical support, and regular performance reviews.\n\n7. Recommendation:\n   Given the potential benefits and the increasing importance of digital transformation in today's business environment, it is recommended that XYZ Corp proceed with the proposed solution."
          },
          {
            "route": "/signup",
            "functions": [
              "get_user_by_email",
              "create_user",
              "get_password_hash"
            ],
            "order_summary": [
              {
                "group_name": "User Management",
                "items": [
                  {
                    "name": "get_user_by_email"
                  },
                  {
                    "name": "create_user"
                  }
                ]
              },
              {
                "group_name": "Security",
                "items": [
                  {
                    "name": "get_password_hash"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure user management system for a company's internal or external applications. The system will be built using Python and will leverage the SQLAlchemy library for database interactions. \n\nThe system will have the following key functionalities:\n\n1. **User Retrieval**: The system will have the ability to retrieve user details from the database using their email address. This will be achieved through the `get_user_by_email` function. This function will be crucial for various operations such as user login, password reset, and account management.\n\n2. **User Creation**: The system will also have the ability to create new users. This will be done through the `create_user` function. This function will first check if a user with the same email already exists in the system. If such a user exists, an error will be raised. Otherwise, a new user will be created. If email notifications are enabled, the function will also send an email to the new user with their account details.\n\n3. **Password Hashing**: To ensure the security of user passwords, the system will not store plain text passwords. Instead, it will store hashed versions of the passwords. This will be done using the `get_password_hash` function, which takes a password and returns its hashed value.\n\nThe implementation of this system will significantly improve the security and efficiency of user management within the company. It will also provide a solid foundation for the development of additional features and functionalities in the future."
          },
          {
            "route": "/{user_id}",
            "functions": [],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their supply chain, which has led to increased operational costs and decreased customer satisfaction due to delayed deliveries. \n\nThe company has been using traditional methods for supply chain management, which lack real-time tracking and data analysis capabilities. The management is considering implementing a digital transformation strategy to improve their supply chain operations. However, they are unsure about the potential benefits and return on investment.\n\nBusiness Case:\n\nTitle: Digital Transformation of Supply Chain Operations at XYZ Corp\n\n1. Situation Analysis:\n   - Current Challenges: Inefficient supply chain management leading to increased operational costs and decreased customer satisfaction.\n   - Proposed Solution: Implementing a digital transformation strategy in supply chain operations.\n\n2. Benefits:\n   - Improved Efficiency: Real-time tracking and data analysis capabilities can streamline supply chain operations, reducing delays and operational costs.\n   - Enhanced Customer Satisfaction: Faster and more reliable deliveries can improve customer satisfaction and loyalty.\n   - Competitive Advantage: Digital transformation can provide a competitive edge in the market, with improved service and operational efficiency.\n\n3. Costs:\n   - Initial Investment: Cost of implementing digital tools and technologies in the supply chain operations.\n   - Training Costs: Expenses related to training staff to use the new systems.\n   - Maintenance Costs: Ongoing costs for system maintenance and updates.\n\n4. Risk Assessment:\n   - Implementation Risks: Potential challenges and delays in implementing the new systems.\n   - Adoption Risks: Resistance from staff in adopting new technologies.\n   - Technical Risks: Potential system failures or cybersecurity threats.\n\n5. Return on Investment:\n   - Cost Savings: Reduction in operational costs due to improved supply chain efficiency.\n   - Revenue Increase: Potential increase in revenue due to improved customer satisfaction and loyalty.\n   - Payback Period: Estimated time it will take to recoup the initial investment from the cost savings and additional revenue.\n\n6. Recommendations:\n   - Conduct a pilot project to test the effectiveness of the digital transformation strategy.\n   - Provide adequate training and support to staff to ensure smooth adoption of the new systems.\n   - Implement robust cybersecurity measures to protect the new systems.\n\nThe business case will be used to guide the decision-making process and provide a clear roadmap for the proposed digital transformation strategy."
          }
        ]
      },
      {
        "name": "utils.py",
        "story": [
          {
            "route": "/test-email/",
            "functions": [
              "generate_test_email",
              "send_email"
            ],
            "order_summary": [
              {
                "group_name": "Email Generation",
                "items": [
                  {
                    "name": "generate_test_email"
                  }
                ]
              },
              {
                "group_name": "Email Sending",
                "items": [
                  {
                    "name": "send_email"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nTitle: Streamlining Email Communication through Automated Python Functions\n\nBackground: \n\nIn the current business environment, email communication is a critical aspect of daily operations. However, the process of drafting, formatting, and sending emails can be time-consuming and prone to human error. This is particularly true for routine emails that follow a similar structure and content, such as project updates, notifications, or test emails. \n\nTo address this, we propose the implementation of two Python functions, `generate_test_email` and `send_email`, which automate the process of creating and sending emails. \n\nThe `generate_test_email` function creates an email with a test message containing the project name and sends it to a specified email address using the provided settings. The `send_email` function sends an email with a customizable subject, HTML content, and recipient address. It also checks if the necessary configuration for email variables is provided and raises an assertion error if not. \n\nBenefits:\n\n1. Efficiency: Automating the process of creating and sending emails can significantly reduce the time spent on these tasks, allowing employees to focus on more critical tasks.\n\n2. Accuracy: The automation of email creation and sending reduces the risk of human error, such as sending an email to the wrong recipient or including incorrect information.\n\n3. Customization: The functions allow for a high degree of customization, including the subject, HTML content, and recipient of the email. This ensures that the emails sent are relevant and tailored to the recipient.\n\n4. Traceability: The functions log the result of sending the email, providing a record for future reference or debugging purposes.\n\nIn conclusion, the implementation of these Python functions can streamline email communication, improving efficiency, accuracy, and customization while providing traceability."
          }
        ]
      },
      {
        "name": "login.py",
        "story": [
          {
            "route": "/login/access-token",
            "functions": [
              "authenticate",
              "create_access_token",
              "get_user_by_email",
              "verify_password"
            ],
            "order_summary": [
              {
                "group_name": "Authentication",
                "items": [
                  {
                    "name": "authenticate"
                  },
                  {
                    "name": "verify_password"
                  }
                ]
              },
              {
                "group_name": "Token Management",
                "items": [
                  {
                    "name": "create_access_token"
                  }
                ]
              },
              {
                "group_name": "User Management",
                "items": [
                  {
                    "name": "get_user_by_email"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure and efficient user authentication system for a web application. The system is designed using Python and leverages the SQLAlchemy library for database operations. \n\nThe system includes several key functions:\n\n1. `authenticate`: This function is responsible for authenticating a user's login credentials against a database. It retrieves the user with the provided email from the database and checks whether the provided password matches the hashed password of the user. If both conditions are met, the function returns the authenticated user object.\n\n2. `verify_password`: This function checks if a given plain text password matches the hashed version of that password. It is a crucial part of the authentication process, ensuring that only users who provide the correct password can access their accounts.\n\n3. `create_access_token`: This function generates an access token with an expiration time and includes specific information about the request's subject. This token is used to maintain a secure session for the user after successful authentication.\n\n4. `get_user_by_email`: This function retrieves a user by their email address from the database. It is used in the authentication process to find the user record that matches the provided email.\n\nThe implementation of this system will enhance the security and user experience of the web application. It will protect user data by ensuring only authenticated users can access their accounts, and it will streamline the login process by efficiently retrieving user records and verifying credentials. \n\nThe system can also be expanded in the future to include additional features such as password reset functionality, multi-factor authentication, and account management features. This flexibility makes it a valuable investment for the business."
          },
          {
            "route": "/login/test-token",
            "functions": [],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their supply chain, which has led to increased operational costs and decreased customer satisfaction. \n\nThe company's supply chain management system is outdated and lacks the necessary features to effectively manage the complex processes involved in their operations. This has resulted in inefficiencies such as delayed deliveries, stockouts, and overstocking. \n\nThe company's management is considering investing in a new supply chain management system to address these issues. However, they need to understand the potential return on investment and the impact on their operations.\n\nBusiness Case:\n\nObjective: The objective of this business case is to analyze the potential benefits and costs associated with implementing a new supply chain management system at XYZ Corp.\n\n1. Situation Analysis: The current supply chain management system is outdated and inefficient, leading to increased operational costs and decreased customer satisfaction.\n\n2. Solution: Implement a new supply chain management system that can effectively manage the complex processes involved in the company's operations.\n\n3. Benefits: The new system will streamline the supply chain processes, reduce operational costs, improve customer satisfaction, and increase overall efficiency. \n\n4. Costs: The costs involved in this project include the purchase of the new system, implementation costs, training costs for employees, and potential downtime during the transition.\n\n5. Return on Investment: The return on investment will be calculated by comparing the cost savings and increased revenue from improved operations against the total cost of the project.\n\n6. Risks: Potential risks include implementation delays, resistance from employees, and potential issues with the new system.\n\n7. Recommendation: Based on the potential benefits and the return on investment, it is recommended that XYZ Corp invests in the new supply chain management system. \n\nThis business case will provide the necessary information for the management of XYZ Corp to make an informed decision about the proposed investment."
          },
          {
            "route": "/password-recovery/{email}",
            "functions": [
              "get_user_by_email",
              "generate_password_reset_token",
              "generate_reset_password_email",
              "send_email"
            ],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their export operations. The company exports to over 50 countries, and each has its unique set of regulations, tariffs, and documentation requirements. \n\nThe company's current export process is manual and time-consuming, leading to delays, errors, and non-compliance issues. The management is considering investing in an automated export management system to streamline their export operations. However, they need to understand the potential benefits and return on investment before making a decision.\n\nBusiness Case:\n\n1. Problem Statement: XYZ Corp's manual export process is inefficient, leading to delays, errors, and non-compliance issues. \n\n2. Proposed Solution: Implement an automated export management system to streamline export operations.\n\n3. Benefits: \n\n   - Increased Efficiency: Automation will reduce the time spent on manual tasks, leading to faster export processing times.\n   - Improved Accuracy: The system will minimize human errors in documentation and compliance, reducing the risk of penalties and shipment delays.\n   - Compliance: The system will stay updated with the latest regulations and tariffs of each country, ensuring compliance.\n   - Scalability: As the company expands its export operations, the system can easily handle the increased volume.\n\n4. Cost: The initial investment in the system, including purchase, implementation, and training costs. \n\n5. ROI: The return on investment will be realized through reduced operational costs, fewer penalties for non-compliance, and increased export volumes due to faster processing times.\n\n6. Risks: Potential risks include system implementation delays, staff resistance to change, and system failures or bugs.\n\n7. Mitigation Strategies: To mitigate these risks, the company should choose a reputable system provider, provide adequate training to staff, and have a contingency plan in place in case of system failures.\n\n8. Recommendation: Given the potential benefits and manageable risks, it is recommended that XYZ Corp invests in an automated export management system."
          },
          {
            "route": "/reset-password/",
            "functions": [
              "verify_password_reset_token",
              "get_user_by_email",
              "get_password_hash"
            ],
            "order_summary": [
              {
                "group_name": "Token Verification",
                "items": [
                  {
                    "name": "verify_password_reset_token"
                  }
                ]
              },
              {
                "group_name": "User Retrieval",
                "items": [
                  {
                    "name": "get_user_by_email"
                  }
                ]
              },
              {
                "group_name": "Password Hashing",
                "items": [
                  {
                    "name": "get_password_hash"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure user management system for a company's digital platform. The system will be built using Python and will leverage the SQLAlchemy library for database management and the JWT library for secure token management.\n\n1. **Problem Statement**: The company currently lacks a secure and efficient user management system for its digital platform. This exposes the company to potential security risks and inefficiencies in user data management.\n\n2. **Proposed Solution**: The proposed solution involves the development of Python functions that handle user data retrieval, password reset token verification, and password hashing. These functions will ensure secure and efficient user management.\n\n    - `get_user_by_email`: This function retrieves a user's data from the database using their email address. It will be used in various operations such as login, password reset, or account management.\n    \n    - `verify_password_reset_token`: This function verifies a password reset token. It decodes the token using a secret key and returns the subject field from the decoded token. If the decoding fails, it returns None. This function will be used in the password reset process.\n    \n    - `get_password_hash`: This function takes a password and returns its hashed value. This function will be used for securely storing passwords in the database.\n\n3. **Benefits**: Implementing these functions will provide several benefits:\n\n    - **Security**: The use of hashed passwords and token verification will enhance the security of the user management system.\n    \n    - **Efficiency**: Retrieving user data based on their email address will streamline user data management and improve the efficiency of operations such as login and password reset.\n    \n    - **Scalability**: The use of SQLAlchemy for database management will allow the system to handle a large number of users, making it scalable as the company grows.\n\n4. **Costs and Risks**: The main costs associated with this project will be the development and testing of the functions. There is also a risk that the functions may not work as expected, leading to potential security vulnerabilities. However, thorough testing and review of the code can mitigate this risk.\n\n5. **ROI**: The return on investment will be realized through improved security, efficiency, and scalability of the user management system. This will lead to a better user experience, potentially increasing user retention and reducing the risk of security breaches."
          },
          {
            "route": "/password-recovery-html-content/{email}",
            "functions": [
              "get_user_by_email",
              "generate_password_reset_token",
              "generate_reset_password_email"
            ],
            "order_summary": [
              {
                "group_name": "User Management",
                "items": [
                  {
                    "name": "get_user_by_email"
                  }
                ]
              },
              {
                "group_name": "Password Management",
                "items": [
                  {
                    "name": "generate_password_reset_token"
                  },
                  {
                    "name": "generate_reset_password_email"
                  }
                ]
              }
            ],
            "story": "Business Case:\n\nThe business case revolves around the development and implementation of a secure and efficient password reset system for a web-based application. The system is designed to enhance user experience and security by providing a streamlined process for users to reset their passwords when necessary.\n\nThe system is built using Python and leverages several functions to achieve its objectives. The first function, `get_user_by_email`, retrieves a user's details from the database using their email address. This function is crucial for identifying the user initiating the password reset process.\n\nThe second function, `generate_password_reset_token`, creates a unique, time-sensitive token for the password reset process. This token is encoded using JWT (JSON Web Tokens), ensuring the security of the process and preventing unauthorized password resets.\n\nThe final function, `generate_reset_password_email`, is responsible for creating the email that will be sent to the user. This email contains a link for the password reset, which incorporates the unique token generated earlier. The function also customizes the email content, including the subject and body, to provide a personalized experience for the user.\n\nThe implementation of this system will improve the security of the application by ensuring that only authorized users can reset their passwords. It will also enhance the user experience by providing a straightforward and efficient process for password resets. This can lead to increased user satisfaction and retention, and potentially attract new users due to the application's robust security measures and user-friendly design."
          }
        ]
      },
      {
        "name": "items.py",
        "story": [
          {
            "route": "/",
            "functions": [],
            "order_summary": [],
            "story": "Background: \n\nA mid-sized manufacturing company, XYZ Corp, has been operating for over 20 years. They have a diverse product portfolio, including automotive parts, home appliances, and industrial machinery. Despite their success, they have been facing challenges in managing their supply chain efficiently. They have been experiencing frequent stock-outs, leading to delayed deliveries and customer dissatisfaction. Additionally, they have been incurring high inventory carrying costs due to overstocking of certain items. The company uses a traditional inventory management system, which is not capable of accurately forecasting demand or optimizing inventory levels. \n\nBusiness Case:\n\nObjective: The primary objective is to improve XYZ Corp's supply chain efficiency by implementing a modern inventory management system. This system will leverage advanced analytics to accurately forecast demand and optimize inventory levels, thereby reducing stock-outs and overstocking.\n\nBenefits: \n\n1. Improved Customer Satisfaction: By reducing stock-outs, the company can ensure timely deliveries, thereby improving customer satisfaction and loyalty.\n\n2. Reduced Costs: By optimizing inventory levels, the company can significantly reduce its inventory carrying costs. \n\n3. Increased Sales: With improved product availability, the company can potentially increase its sales.\n\n4. Enhanced Decision Making: The advanced analytics provided by the new system can aid in strategic decision making.\n\nCosts: The costs involved in this project include the cost of the new inventory management system, implementation costs, and training costs for the employees.\n\nRisks: The risks involved include potential resistance from employees, technical glitches during implementation, and the new system not delivering the expected benefits.\n\nRecommendation: Given the significant benefits and manageable risks, it is recommended that XYZ Corp proceed with the implementation of the new inventory management system. The company should also invest in change management and training to ensure a smooth transition."
          },
          {
            "route": "/{id}",
            "functions": [],
            "order_summary": [],
            "story": "Background: A manufacturing company, XYZ Corp, has been experiencing a decline in sales over the past two years. The company has been using traditional methods of marketing and sales, which have not been effective in the current digital age. The company's production process is also outdated, leading to high production costs and low-quality products. The company has not invested in new technologies or processes, which has resulted in a lack of innovation and competitiveness. The company's financial performance has been declining, and the company is at risk of going out of business if changes are not made.\n\nBusiness Case:\n\n1. Problem Statement: XYZ Corp is facing a decline in sales and profitability due to outdated marketing and sales methods, inefficient production processes, and a lack of innovation.\n\n2. Proposed Solution: The company needs to invest in digital marketing strategies, modernize its production process, and foster a culture of innovation. \n\n3. Benefits: By adopting digital marketing strategies, the company can reach a wider audience and increase sales. Modernizing the production process can reduce costs and improve product quality, leading to increased customer satisfaction and repeat business. Fostering a culture of innovation can lead to the development of new products and services, giving the company a competitive edge.\n\n4. Costs: The company will need to invest in new technologies and training for employees. The cost of these investments will be offset by the increase in sales and reduction in production costs.\n\n5. Risks: There is a risk that the new strategies may not be as effective as expected, or that employees may resist the changes. These risks can be mitigated through careful planning and change management.\n\n6. Recommendations: The company should start by conducting a market analysis to identify the most effective digital marketing strategies. It should also conduct a process analysis to identify areas for improvement in the production process. The company should then develop a change management plan to ensure a smooth transition to the new strategies and processes. \n\n7. Conclusion: By investing in digital marketing, modernizing its production process, and fostering a culture of innovation, XYZ Corp can increase sales, reduce costs, and become more competitive. This will ensure the company's long-term survival and growth."
          }
        ]
      }
    ],
    "class_data": "Based on the provided class definitions, it appears that this project involves a user authentication and management system, as well as a functionality for creating, updating, and deleting items. The `UserBase` class represents the common attributes of all users, while `UserCreate`, `UserRegister`, `UserUpdateMe`, and `UserUpdate` define the parameters required for creating new users, registering new users, updating existing user information (excluding password), and updating email and full name respectively.\n\nThe `UpdatePassword` class allows users to update their current password before setting a new one. The `UserOut` and `UsersOut` classes are used to return the details of individual users or lists of users respectively, while the `ItemBase` and `ItemCreate` classes define the basic attributes of items and parameters required for creating new items respectively.\n\nThe `ItemUpdate` class allows existing item information to be updated, and `ItemOut` and `ItemsOut` return individual item details or lists of items respectively. The `Message` class seems to represent messages used in communication between users.\n\nThe `Token`, `TokenPayload`, and `NewPassword` classes relate to token management and password reset functionality. There are also several settings-related classes, including `EmailData`, which appears to be related to email communications, as well as various server configuration settings such as `SECRET_KEY`, `ACCESS_TOKEN_EXPIRE_MINUTES`, etc.\n\nOverall, these class definitions seem to cover a wide range of functionalities and data structures required for this web application.",
    "class_data_comments": [
      {
        "name": "UserBase",
        "content": "Here's an example of how the commented function might look like based on the given user input:\n\n```python\ndef get_user_details(user):\n    \"\"\"\n    This function takes a user object as input and returns a tuple containing their email address,\n    boolean indicating whether they are actively using the system, boolean indicating whether\n    they have administrative privileges, and their full name. The inputs are:\n    - 'email': user's unique email address used for login\n    - 'is_active': True if the user is currently using the system, False otherwise\n    - 'is_superuser': True if the user has administrator privileges, False otherwise\n    - 'full_name': The full name of the user as entered during registration\n    \"\"\"\n    return user.email, user.is_active, user.is_superuser, user.full_name\n```"
      },
      {
        "name": "UserCreate",
        "content": "Def generate_commented_function(password):\n    \"\"\"\n    This function takes a password as input and returns None (as the password is not returned for security purposes). The input password is processed and stored securely in the system. It does not perform any additional functionality beyond this. Note that for optimal security, it is recommended to use a dedicated password management library or framework instead of implementing your own password storage logic.\n    :param password: A string containing the user's password.\n    \"\"\"\n    # Securely store the password in the system using industry-standard encryption techniques and access control mechanisms.\n    pass  # Returning None to prevent accidental exposure of the password.\n```"
      },
      {
        "name": "UserRegister",
        "content": "Def get_user_information(email, password, full_name):\n    \"\"\"\n    This function takes in three arguments representing a user's email address, password, and full name.\n    It does not return anything but rather collects this information for use elsewhere in the program.\n    :param email: The unique identifier for the user's account.\n    :param password: A secret string used to verify the user's identity.\n    :param full_name: The user's given name and surname, displayed publicly.\n    \"\"\"\n```\nThe comments provide context and clarity around the function's parameters and purpose, making it easier for other developers (or future versions of yourself) to understand and use the function."
      },
      {
        "name": "UserUpdate",
        "content": "Here's the commented version of that function:\n\n```python\ndef get_credentials(email: str, password: str) -> tuple:\n    \"\"\"\n    This function returns a tuple containing the user's email and password.\n\n    :param email: The email address of the user. Type: str.\n    :param password: The password of the user. Type: str.\n    :return: A tuple containing the email and password. Type: tuple.\n    \"\"\"\n```\n\nIn this example, the function takes two arguments `email` (type `str`) and `password` (also type `str`). It returns a tuple containing both these values. The comments above the function header describe the function's purpose, parameters, and return value."
      },
      {
        "name": "UserUpdateMe",
        "content": "Def get_user_info(required_fields):\n    \"\"\"\n    This function takes a list of required fields as input and returns a dictionary containing the necessary user information for those fields.\n\n    Args:\n    required_fields (list): A list of field names that are required for the user info.\n\n    Returns:\n    dict: A dictionary containing the user information for the specified fields.\n    \"\"\"\n```"
      },
      {
        "name": "UpdatePassword",
        "content": "Here's the commented version of this Python function:\n\n```python\ndef change_password(current_password, new_password):\n    \"\"\"\n    This function takes two passwords as arguments - the current password and the new password.\n    The purpose of this function is to change the user's password.\n    \n    Arguments:\n        current_password (str): The user's current password.\n        new_password (str): The new password that the user wants to set.\n        \n    Returns:\n        None, but the function updates the user's password in the database.\n    \"\"\"\n``` \n\nI hope this helps clarify the purpose and functionality of the function for you! Let me know if there's anything else I can do for you."
      },
      {
        "name": "User",
        "content": "Def get_user_data(user_info: dict) -> list[str]:\n    \"\"\"\n    This function takes a dictionary representing user information,\n    and returns a list of the values for the keys 'id', 'hashed_password', and 'items'.\n    \n    Args:\n    - user_info (dict): A dictionary containing user data. The keys are expected to be 'id', 'hashed_password', and 'items'.\n    - Return type (list[str]): The function returns a list of strings, containing the values for the specified keys.\n    \"\"\"\n```"
      },
      {
        "name": "UserOut",
        "content": "# Define a function called `get_id` that takes no arguments (since the input is a list with only one item, an empty tuple would also work here) and returns that single item\ndef get_id():\n    # The `['id']` input represents a list with a single string 'id'. We return this string.\n    return 'id'\n```\n\nNote: If the user input was something more complex, such as:\n\n```python\ndef calculate_average(list1, list2):\n    total = 0\n    for num in list1 + list2:\n        total += num\n    average = total / (len(list1) + len(list2))\n    return average\n```\n\nThe commented version would look like this:\n\n```python\n# Define a function called `calculate_average` that takes two lists, `list1` and `list2`, as arguments\n# We initialize a variable `total` to 0, then loop through both input lists (`list1` and `list2`) using the `for num in list1 + list2:` syntax.\n# Inside the loop, we add each number (`num`) to the `total` variable.\n# After all numbers have been added, we calculate the average by dividing the total by the sum of the lengths of both input lists.\ndef calculate_average(list1, list2):\n    total = 0\n    for num in list1 + list2:\n        total += num\n    average = total / (len(list1) + len(list2))\n    return average\n```"
      },
      {
        "name": "UsersOut",
        "content": "Here's how the system could generate a commented version of this function based on its analysis:\n\n```python\n# This function takes in two parameters, 'data' and 'count'.\n# It does not return anything.\ndef my_function(data, count):\n    # We iterate over the 'data' list 'count' number of times.\n    for I in range(count):\n        # For each iteration, we do something with the current element of 'data'.\n        # In this example, we simply print it.\n        print(data[i])\n```"
      },
      {
        "name": "ItemBase",
        "content": "Def get_metadata(title, description):\n    \"\"\"\n    This function takes in two arguments, `title` and `description`, and returns a tuple containing both of them as metadata.\n    :param title: A string representing the title of the item being described.\n    :param description: A string representing a detailed description of the item being described.\n    :return: A tuple containing both the title and description as metadata.\n    \"\"\"\n```"
      },
      {
        "name": "ItemCreate",
        "content": "```python\n# This function takes a single argument 'title' (a string) and returns it as is\ndef title(title: str) -> str:\n    # No logic implemented inside the function, simply passing the argument back\n    return title\n```"
      },
      {
        "name": "ItemUpdate",
        "content": "```python\n# This function takes in a single parameter, 'title', and returns only that value\ndef return_title(title):\n    \"\"\"\n    This function accepts a single argument, 'title', which is expected to be a string.\n    The function simply returns the input title without any modifications.\n    \"\"\"\n    return title\n```"
      },
      {
        "name": "Item",
        "content": "Def get_column_names(collection):\n    \"\"\"\n    This function returns a list containing the names of all columns in the given MongoDB collection.\n    \n    Parameters:\n    - collection (pymongo.Collection): A MongoDB collection object to fetch column names from.\n    \n    Returns:\n    - list: A list containing the names of all columns in the collection.\n    \"\"\"\n    return ['id', 'title', 'owner_id', 'owner']  # This is the original function body with comments explaining its purpose, parameters, and return value.\n```"
      },
      {
        "name": "ItemOut",
        "content": "Here's how the system would generate commented code for this user input:\n\n```python\n# Function to extract 'id' and 'owner_id' fields from a dictionary-like object\n# Parameters:\n#    - dictionary (dict): The input object containing the desired fields\n# Returns:\n#    - tuple of values for 'id' and 'owner_id', or None if not found\ndef extract_fields(dictionary):\n    # Check if 'id' is present in the dictionary\n    id = dictionary.get('id')\n    # If 'id' is not present, return None for that field\n    if id is None:\n        return None, dictionary.get('owner_id')\n    # Otherwise, extract both fields and return them as a tuple\n    owner_id = dictionary.get('owner_id')\n    return id, owner_id\n```\n\nNote: The exact behavior of the function may differ based on the input format and desired output type, but this example should provide a general idea of how the system would generate commented code for this specific user input."
      },
      {
        "name": "ItemsOut",
        "content": "```python\ndef count_occurrences(data, count=None):\n    \"\"\"\n    This function takes a list of data as input and returns the number of occurrences of a specific item in it. \n    If no item is specified (i.e., the `count` parameter is not provided), the function returns a dictionary containing the number of occurrences of each unique item in the data.\n    \n    Args:\n    - data: A list or tuple containing the input data.\n    - count (optional): The specific item to count. If not provided, all items will be counted. Default is None.\n    Returns:\n    - int: The number of occurrences of the specified `count` item in the data, if provided. Otherwise, a dictionary containing the counts for all unique items in the data.\n    \"\"\"\n```"
      },
      {
        "name": "Message",
        "content": "```python\n# This function returns a message\ndef message():\n    pass\n```\n\nOr for a more complex example, let's say the user inputs:\n```python\n[ 'calculate_area', 'Computes the area of a rectangle based on its width and height' ]\n```\n\nThen the commented version would be:\n```python\n# Function to calculate the area of a rectangle based on its width and height\ndef calculate_area(width, height):\n    # Calculate the area using the formula width * height\n    area = width * height\n    return area\n```"
      },
      {
        "name": "Token",
        "content": "Here's an example of how the system might generate commented code for this input function:\n\n```python\ndef get_authentication_tokens(access_token: str, token_type: str) -> tuple[str, str]:\n    \"\"\"\n    Retrieves a user's authentication tokens from the authentication server.\n    \n    Parameters:\n    access_token (str): The authorization grant issued to the client by the resource server.\n    token_type (str): The type of token returned, such as \"bearer\" or \"mac\".\n    \n    Returns:\n    tuple[str, str]: A tuple containing the user's access token and token type.\n    \"\"\"\n    # Code to retrieve authentication tokens goes here...\n```\n\nNote that in this example, the system has identified that the function takes two positional arguments (`access_token` and `token_type`) of types `str`, returns a tuple containing both `str` values as its return value. It also accurately identifies what the function does and how it is used in its docstring."
      },
      {
        "name": "TokenPayload",
        "content": "Def sub(x: float, y: float) -> float:\n    \"\"\"\n    This function takes two floating point numbers, x and y, as input and returns their difference, which is calculated by subtracting y from x.\n\n    Parameters:\n    x (float): The first number.\n    y (float): The second number.\n\n    Returns:\n    float: The difference between x and y.\n    \"\"\"\n```\nIn this case, the user input is just the name of the function, `sub`. Based on that, we can deduce the function's purpose, parameters, and return type using Python's syntax rules.\n\nThe function `sub` takes two arguments `x` and `y`, both of which are expected to be float types. It returns a float value representing their difference. The function is named `sub`, which suggests that it performs subtraction operation between the input parameters.\n\nUsing this information, we can create a commented version of the function. Note that while generating comments for the function, we assume that the user has provided the correct syntax and input arguments. In case of errors in the input code or unexpected inputs to the function, the comments might not be accurate."
      },
      {
        "name": "NewPassword",
        "content": "Here's the commented version of the function based on its signature:\n\n```python\n# Function to reset user's password\n# Takes two parameters, 'token' (a string representing the reset link) and 'new_password' (a new password as a string)\ndef reset_password(token: str, new_password: str) -> None:\n    # The function returns None since password resets are not expected to return anything useful.\n```\n\nThe comments provide clarity about the function's purpose and parameters, making it easier for others (or future self) to understand and maintain the code."
      },
      {
        "name": "EmailData",
        "content": "```python\ndef send_email(html_content: str, subject: str) -> None:\n    \"\"\"\n    Sends an email with the given HTML content and subject.\n    \n    :param html_content: The HTML content of the email message.\n    :param subject: The subject line of the email.\n    :return: None (as this is a void function).\n    \"\"\"\n``` \n\nExplanation:\n\n- The first line of the commented version contains the original function name and its parameters in parentheses, with their respective types. This helps to clarify what arguments are expected by the function.\n- The docstring (a string enclosed in triple quotes) provides a detailed description of what the function does, including any input parameters, output values, and potential exceptions or error conditions.\n- The return type is also specified, which is useful for functions that return a value, as it helps to ensure that the correct data type is returned. In this case, since `send_email()` is a void function (meaning it does not return any value), we set the return type to `None`.\n- The docstring should include a detailed description of what the function does, how it works, and any important caveats or limitations that users should be aware of.\n- In general, comments should be added in a way that enhances clarity and readability, without being overly verbose or redundant."
      },
      {
        "name": "Settings",
        "content": "Here's a commented version of the function based on the analysis:\n\n```python\ndef configure_app(model_config: str,  # Config for model server\n                 API_V1_STR: str = 'v1',   # Default version is v1\n                 SECRET_KEY: str = None,    # Required for session management\n                 ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 5,   # Default access token expiration time\n                 DOMAIN: str = 'localhost',        # Domain for the app\n                 ENVIRONMENT: str = 'development',      # Development or production environment\n                 BACKEND_CORS_ORIGINS: List[str] = ['http://localhost:3000', 'https://example.com'],   # Allowed cross-origin resource sharing (CORS) origins\n                 PROJECT_NAME: str = None,       # Project name for logging and error reporting\n                 SENTRY_DSN: str = None,          # Optional Sentry error tracking integration\n                 POSTGRES_SERVER: str = 'localhost',  # PostgreSQL server hostname or IP address\n                 POSTGRES_PORT: int = 5432,      # Default PostgreSQL port number\n                 POSTGRES_USER: str = None,        # Username for accessing the database\n                 POSTGRES_PASSWORD: str = None,    # Password for accessing the database\n                 POSTGRES_DB: str = None,          # Database name to use\n                 SMTP_TLS: bool = False,            # Enable or disable STARTLS for sending emails\n                 SMTP_SSL: bool = False,           # Enable or disable SSL/TLS for sending emails\n                 SMTP_PORT: int = 587,              # Default SMTP port number\n                 SMTP_HOST: str = 'smtp.gmail.com',   # Gmail SMTP server hostname or IP address\n                 SMTP_USER: str = None,            # Email address to use for sending emails\n                 SMTP_PASSWORD: str = None,        # Password for accessing the email account\n                 EMAILS_FROM_EMAIL: str = 'noreply@example.com',   # Email address to send from\n                 EMAILS_FROM_NAME: str = 'Example App',     # Name to use when sending emails\n                 EMAIL_RESET_TOKEN_EXPIRE_HOURS: int = 24,    # Number of hours before reset token expires\n                 EMAIL_TEST_USER: bool = False,            # Enable or disable testing user functionality\n                 FIRST_SUPERUSER: str = None,          # First superuser username (for testing and development)\n                 FIRST_SUPERUSER_PASSWORD: str = None,    # Password for the first superuser account\n                 USERS_OPEN_REGISTRATION: bool = True,         # Enable or disable user registration functionality\n):\n    \"\"\"\n    Configure various settings and options for the app.\n\n    :param model_config: Config for the model server (e.g., address, port number).\n    :type model_config: str\n    \n    :param API_V1_STR: Default version of the API (e.g., 'v1').\n    :type API_V1_STR: str\n    \n    :param SECRET_KEY: Required for session management.\n    :type SECRET_KEY: str\n    \n    :param ACCESS_TOKEN_EXPIRE_MINUTES: Default access token expiration time (in minutes).\n    :type ACCESS_TOKEN_EXPIRE_MINUTES: int\n    \n    :param DOMAIN: Domain for the app.\n    :type DOMAIN: str\n    \n    :param ENVIRONMENT: Development or production environment (e.g., 'development' or 'production').\n    :type ENVIRONMENT: str\n    \n    :param BACKEND_CORS_ORIGINS: List of allowed cross-origin resource sharing (CORS) origins (e.g., ['http://localhost:3000', 'https://example.com']).\n    :type BACKEND_CORS_ORIGINS: List[str]\n    \n    :param PROJECT_NAME: Project name for logging and error reporting (optional).\n    :type PROJECT_NAME: str\n    \n    :param SENTRY_DSN: Optional Sentry error tracking integration DSN (URL or secret key).\n    :type SENTRY_DSN: str\n    \n    :param POSTGRES_SERVER: PostgreSQL server hostname or IP address.\n    :type POSTGRES_SERVER: str\n    \n    :param POSTGRES_PORT: Default PostgreSQL port number (5432).\n    :type POSTGRES_PORT: int\n    \n    :param POSTGRES_USER: Username for accessing the database.\n    :type POSTGRES_USER: str\n    \n    :param POSTGRES_PASSWORD: Password for accessing the database.\n    :type POSTGRES_PASSWORD: str\n    \n    :param POSTGRES_DB: Database name to use (optional).\n    :type POSTGRES_DB: str\n    \n    :param SMTP_TLS: Enable or disable STARTLS for sending emails.\n    :type SMTP_TLS: bool\n    \n    :param SMTP_SSL: Enable or disable SSL/TLS for sending emails.\n    :type SMTP_SSL: bool\n    \n    :param SMTP_PORT: Default SMTP port number (587).\n    :type SMTP_PORT: int\n    \n    :param SMTP_HOST: Gmail SMTP server hostname or IP address.\n    :type SMTP_HOST: str\n    \n    :param SMTP_USER: Email address to use for sending emails (optional).\n    :type SMTP_USER: str\n    \n    :param SMTP_PASSWORD: Password for accessing the email account (optional).\n    :type SMTP_PASSWORD: str\n    \n    :param EMAILS_FROM_EMAIL: Email address to send from.\n    :type EMAILS_FROM_EMAIL: str\n    \n    :param EMAILS_FROM_NAME: Name to use when sending emails (optional).\n    :type EMAILS_FROM_NAME: str\n    \n    :param EMAIL_RESET_TOKEN_EXPIRE_HOURS: Number of hours before reset token expires.\n    :type EMAIL_RESET_TOKEN_EXPIRE_HOURS: int\n    \n    :param EMAIL_TEST_USER: Enable or disable testing user functionality (optional).\n    :type EMAIL_TEST_USER: bool\n    \n    :param FIRST_SUPERUSER: First superuser username (for testing and development) (optional).\n    :type FIRST_SUPERUSER: str\n    \n    :param FIRST_SUPERUSER_PASSWORD: Password for the first superuser account (optional).\n    :type FIRST_SUPERUSER_PASSWORD: str\n    \n    :param USERS_OPEN_REGISTRATION: Enable or disable user registration functionality (optional).\n    :type USERS_OPEN_REGISTRATION: bool\n    \"\"\"\n```"
      }
    ]
  }
}